"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrpcInternalError = exports.XrpcUpstreamError = exports.XrpcAuthenticationError = exports.XrpcResponseError = exports.XrpcError = exports.LexError = exports.RETRYABLE_HTTP_STATUS_CODES = void 0;
exports.isXrpcErrorPayload = isXrpcErrorPayload;
exports.asXrpcFailure = asXrpcFailure;
const lex_data_1 = require("@atproto/lex-data");
Object.defineProperty(exports, "LexError", { enumerable: true, get: function () { return lex_data_1.LexError; } });
const lex_schema_1 = require("@atproto/lex-schema");
const www_authenticate_js_1 = require("./www-authenticate.js");
/**
 * HTTP status codes that indicate a transient error that may succeed on retry.
 *
 * Includes:
 * - 408 Request Timeout
 * - 425 Too Early
 * - 429 Too Many Requests (rate limited)
 * - 500 Internal Server Error
 * - 502 Bad Gateway
 * - 503 Service Unavailable
 * - 504 Gateway Timeout
 * - 522 Connection Timed Out (Cloudflare)
 * - 524 A Timeout Occurred (Cloudflare)
 */
exports.RETRYABLE_HTTP_STATUS_CODES = new Set([
    408, 425, 429, 500, 502, 503, 504, 522, 524,
]);
/**
 * All unsuccessful responses should follow a standard error response
 * schema. The Content-Type should be application/json, and the payload
 * should be a JSON object with the following fields:
 *
 * - `error` (string, required): type name of the error (generic ASCII
 *   constant, no whitespace)
 * - `message` (string, optional): description of the error, appropriate for
 *   display to humans
 *
 * This function checks whether a given payload matches this schema.
 */
function isXrpcErrorPayload(payload) {
    return (payload != null &&
        payload.encoding === 'application/json' &&
        lex_schema_1.lexErrorDataSchema.matches(payload.body));
}
/**
 * Abstract base class for all XRPC errors.
 *
 * Extends {@link LexError} and implements {@link ResultFailure} for use with
 * safe/result-based error handling patterns.
 *
 * @typeParam M - The XRPC method type (Procedure or Query)
 * @typeParam N - The error code type
 * @typeParam TReason - The reason type for ResultFailure
 *
 * @see {@link XrpcResponseError} - For valid XRPC error responses
 * @see {@link XrpcUpstreamError} - For invalid/unexpected responses
 * @see {@link XrpcInternalError} - For network/internal errors
 */
class XrpcError extends lex_data_1.LexError {
    method;
    name = 'XrpcError';
    constructor(method, error, message = `${error} Lexicon RPC error`, options) {
        super(error, message, options);
        this.method = method;
    }
    /**
     * @see {@link ResultFailure.success}
     */
    success = false;
    matchesSchema() {
        return this.method.errors?.includes(this.error) ?? false;
    }
}
exports.XrpcError = XrpcError;
/**
 * Error class for valid XRPC error responses from the server.
 *
 * This represents a properly formatted XRPC error where the server returned
 * a non-2xx status with a valid JSON error payload containing `error` and
 * optional `message` fields.
 *
 * Use {@link matchesSchema} to check if the error matches the method's declared
 * error types for type-safe error handling.
 *
 * @typeParam M - The XRPC method type
 * @typeParam N - The error code type (inferred from method or generic)
 *
 * @example Handling specific errors
 * ```typescript
 * try {
 *   await client.xrpc(someMethod, options)
 * } catch (err) {
 *   if (err instanceof XrpcResponseError && err.error === 'RecordNotFound') {
 *     // Handle not found case
 *   }
 * }
 * ```
 */
class XrpcResponseError extends XrpcError {
    response;
    payload;
    name = 'XrpcResponseError';
    constructor(method, response, payload, options) {
        const { error, message } = payload.body;
        super(method, error, message, options);
        this.response = response;
        this.payload = payload;
    }
    get reason() {
        return this;
    }
    shouldRetry() {
        return exports.RETRYABLE_HTTP_STATUS_CODES.has(this.response.status);
    }
    toJSON() {
        return this.payload.body;
    }
    toResponse() {
        // Re-expose schema-valid errors as-is to downstream clients
        if (this.matchesSchema()) {
            const status = this.response.status >= 500 ? 502 : this.response.status;
            return Response.json(this.toJSON(), { status });
        }
        return this.response.status >= 500
            ? // The upstream server had an error, return a generic upstream failure
                Response.json({ error: 'UpstreamFailure' }, { status: 502 })
            : // If the error is on our side, return a generic internal server error
                Response.json({ error: 'InternalServerError' }, { status: 500 });
    }
    get body() {
        return this.payload.body;
    }
}
exports.XrpcResponseError = XrpcResponseError;
/**
 * Error class for 401 Unauthorized XRPC responses.
 *
 * Extends {@link XrpcResponseError} with access to parsed WWW-Authenticate header
 * information, useful for implementing authentication flows.
 *
 * Authentication errors are never retryable as they require user intervention
 * (e.g., re-authentication, token refresh).
 *
 * @typeParam M - The XRPC method type
 * @typeParam N - The error code type
 *
 * @example Handling authentication errors
 * ```typescript
 * try {
 *   await client.xrpc(someMethod, options)
 * } catch (err) {
 *   if (err instanceof XrpcAuthenticationError) {
 *     const { DPoP } = err.wwwAuthenticate
 *     if (DPoP?.error === 'use_dpop_nonce') {
 *       // Handle DPoP nonce requirement
 *     }
 *   }
 * }
 * ```
 */
class XrpcAuthenticationError extends XrpcResponseError {
    name = 'XrpcAuthenticationError';
    shouldRetry() {
        return false;
    }
    #wwwAuthenticateCached;
    /**
     * Parsed WWW-Authenticate header from the response.
     * Contains authentication scheme parameters (e.g., Bearer realm, DPoP nonce).
     */
    get wwwAuthenticate() {
        return (this.#wwwAuthenticateCached ??=
            (0, www_authenticate_js_1.parseWWWAuthenticateHeader)(this.response.headers.get('www-authenticate')) ?? {});
    }
}
exports.XrpcAuthenticationError = XrpcAuthenticationError;
/**
 * Error class for invalid or unprocessable XRPC responses from upstream servers.
 *
 * This occurs when the server returns a response that doesn't conform to the
 * XRPC protocol, such as:
 * - Missing or invalid Content-Type header
 * - Response body that doesn't match the method's output schema
 * - Non-JSON error responses
 * - Responses from non-XRPC endpoints
 *
 * The error code is always 'UpstreamFailure' and maps to HTTP 502 Bad Gateway
 * when converted to a response.
 *
 * @typeParam M - The XRPC method type
 */
class XrpcUpstreamError extends XrpcError {
    response;
    payload;
    name = 'XrpcUpstreamError';
    constructor(method, response, payload = null, message = `Unexpected upstream XRPC response`, options) {
        super(method, 'UpstreamFailure', message, options);
        this.response = response;
        this.payload = payload;
    }
    get reason() {
        return this;
    }
    shouldRetry() {
        return exports.RETRYABLE_HTTP_STATUS_CODES.has(this.response.status);
    }
    toResponse() {
        return Response.json(this.toJSON(), { status: 502 });
    }
}
exports.XrpcUpstreamError = XrpcUpstreamError;
/**
 * Error class for internal/client-side errors during XRPC requests.
 *
 * This represents errors that occur before or during the request that are not
 * server responses, such as:
 * - Network errors (connection refused, DNS failure)
 * - Request timeouts
 * - Request aborted via AbortSignal
 * - Invalid request construction
 *
 * The error code is always 'InternalServerError' and these errors are
 * optimistically considered retryable.
 *
 * @typeParam M - The XRPC method type
 */
class XrpcInternalError extends XrpcError {
    name = 'XrpcInternalError';
    constructor(method, message, options) {
        super(method, 'InternalServerError', message ?? 'Unable to fulfill XRPC request', options);
    }
    get reason() {
        return this;
    }
    shouldRetry() {
        // Ideally, we would inspect the reason to determine if it's retryable
        // (by detecting network errors, timeouts, etc.). Since these cases are
        // highly platform-dependent, we optimistically assume all internal
        // errors are retryable.
        return true;
    }
    toResponse() {
        // Do not expose internal error details to downstream clients
        return Response.json({ error: this.error }, { status: 500 });
    }
}
exports.XrpcInternalError = XrpcInternalError;
/**
 * Converts an unknown error into an appropriate {@link XrpcFailure} type.
 *
 * If the error is already an XrpcFailure for the given method, returns it as-is.
 * Otherwise, wraps it in an {@link XrpcInternalError}.
 *
 * @param method - The XRPC method that was called
 * @param cause - The error to convert
 * @returns An XrpcFailure instance
 *
 * @example
 * ```typescript
 * try {
 *   const response = await fetch(...)
 *   // ... process response
 * } catch (err) {
 *   return asXrpcFailure(method, err)
 * }
 * ```
 */
function asXrpcFailure(method, cause) {
    if (cause instanceof XrpcResponseError ||
        cause instanceof XrpcUpstreamError ||
        cause instanceof XrpcInternalError) {
        if (cause.method === method)
            return cause;
    }
    return new XrpcInternalError(method, undefined, { cause });
}
//# sourceMappingURL=errors.js.map