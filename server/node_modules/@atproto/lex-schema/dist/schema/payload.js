"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Payload = void 0;
exports.payload = payload;
exports.jsonPayload = jsonPayload;
const object_js_1 = require("./object.js");
/**
 * Represents a payload definition for Lexicon endpoints.
 *
 * Payloads define the body format for HTTP requests and responses.
 * They consist of an encoding (MIME type) and an optional schema
 * for validating the body content.
 *
 * @template TEncoding - The MIME type string, or undefined for no body
 * @template TPayload - The schema type for body validation
 *
 * @example
 * ```ts
 * const jsonPayload = new Payload('application/json', l.object({ data: l.string() }))
 * const binaryPayload = new Payload('image/*', undefined)
 * const noPayload = new Payload(undefined, undefined)
 * ```
 */
class Payload {
    encoding;
    schema;
    constructor(encoding, schema) {
        this.encoding = encoding;
        this.schema = schema;
        if (encoding === undefined && schema !== undefined) {
            throw new TypeError('schema cannot be defined when encoding is undefined');
        }
    }
    /**
     * Checks whether the given content-type matches the expected payload schema's
     * encoding.
     */
    matchesEncoding(contentType) {
        const { encoding } = this;
        // Handle undefined cases
        if (encoding === undefined) {
            // Expecting no body
            return contentType == null;
        }
        else if (contentType == null) {
            // Expecting a body, but got no content-type
            return false;
        }
        if (encoding === '*/*') {
            return true;
        }
        const mime = contentType?.split(';', 1)[0].trim();
        if (encoding.endsWith('/*')) {
            return mime.startsWith(encoding.slice(0, -1));
        }
        // Invalid: Lexicon can only specify "*/*" or "type/*" wildcards
        if (encoding.includes('*')) {
            return false;
        }
        return encoding === mime;
    }
}
exports.Payload = Payload;
/**
 * Creates a payload definition for Lexicon endpoint bodies.
 *
 * Defines the expected MIME type and optional validation schema for
 * request or response bodies.
 *
 * @param encoding - MIME type string (e.g., 'application/json', 'image/*'), or undefined for no body
 * @param validator - Optional schema for validating the body content. Must be undefined if encoding is undefined.
 * @returns A new {@link Payload} instance
 *
 * @example
 * ```ts
 * // JSON payload with schema
 * const output = l.payload('application/json', l.object({
 *   posts: l.array(postSchema),
 *   cursor: l.optional(l.string()),
 * }))
 *
 * // Binary payload (no schema validation)
 * const blobInput = l.payload('*\/*', undefined)
 *
 * // Image payload with wildcard
 * const imageInput = l.payload('image/*', undefined)
 *
 * // No payload (for endpoints without body)
 * const noBody = l.payload()
 * ```
 */
/*@__NO_SIDE_EFFECTS__*/
function payload(encoding = undefined, validator = undefined) {
    return new Payload(encoding, validator);
}
/**
 * Creates a JSON payload with an object schema.
 *
 * Convenience function for the common case of JSON request/response bodies.
 * Equivalent to `l.payload('application/json', l.object(properties))`.
 *
 * @param properties - Object mapping property names to validators
 * @returns A new {@link Payload} instance with 'application/json' encoding
 *
 * @example
 * ```ts
 * // Query output
 * const profileOutput = l.jsonPayload({
 *   did: l.string({ format: 'did' }),
 *   handle: l.string({ format: 'handle' }),
 *   displayName: l.optional(l.string()),
 * })
 *
 * // Procedure input
 * const createPostInput = l.jsonPayload({
 *   text: l.string({ maxGraphemes: 300 }),
 *   createdAt: l.string({ format: 'datetime' }),
 * })
 * ```
 */
/*@__NO_SIDE_EFFECTS__*/
function jsonPayload(properties) {
    return payload('application/json', (0, object_js_1.object)(properties));
}
//# sourceMappingURL=payload.js.map