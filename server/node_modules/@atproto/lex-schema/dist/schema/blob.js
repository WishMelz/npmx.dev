"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blob = exports.BlobSchema = exports.isLegacyBlobRef = exports.isBlobRef = void 0;
const lex_data_1 = require("@atproto/lex-data");
Object.defineProperty(exports, "isBlobRef", { enumerable: true, get: function () { return lex_data_1.isBlobRef; } });
Object.defineProperty(exports, "isLegacyBlobRef", { enumerable: true, get: function () { return lex_data_1.isLegacyBlobRef; } });
const core_js_1 = require("../core.js");
const memoize_js_1 = require("../util/memoize.js");
/**
 * Schema for validating blob references in AT Protocol.
 *
 * Validates BlobRef objects which contain a CID reference to binary data,
 * along with metadata like MIME type and size. Can optionally accept
 * legacy blob reference format.
 *
 * @template TOptions - The configuration options type
 *
 * @example
 * ```ts
 * const schema = new BlobSchema({ accept: ['image/*'], maxSize: 1000000 })
 * const result = schema.validate(blobRef)
 * ```
 */
class BlobSchema extends core_js_1.Schema {
    options;
    type = 'blob';
    constructor(options) {
        super();
        this.options = options;
    }
    validateInContext(input, ctx) {
        const blob = input?.$type !== undefined
            ? (0, lex_data_1.isBlobRef)(input, this.options)
                ? input
                : null
            : this.options?.allowLegacy === true && (0, lex_data_1.isLegacyBlobRef)(input)
                ? input
                : null;
        if (!blob) {
            return ctx.issueUnexpectedType(input, 'blob');
        }
        const accept = this.options?.accept;
        if (accept && !matchesMime(blob.mimeType, accept)) {
            return ctx.issueInvalidPropertyValue(blob, 'mimeType', accept);
        }
        const maxSize = this.options?.maxSize;
        if (maxSize != null && 'size' in blob && blob.size > maxSize) {
            return ctx.issueTooBig(blob, 'blob', maxSize, blob.size);
        }
        return ctx.success(blob);
    }
    matchesMime(mime) {
        const accept = this.options?.accept;
        if (!accept)
            return true;
        return matchesMime(mime, accept);
    }
}
exports.BlobSchema = BlobSchema;
function matchesMime(mime, accepted) {
    if (accepted.includes('*/*'))
        return true;
    if (accepted.includes(mime))
        return true;
    for (const value of accepted) {
        if (value.endsWith('/*') && mime.startsWith(value.slice(0, -1))) {
            return true;
        }
    }
    return false;
}
/**
 * Creates a blob schema for validating blob references with optional constraints.
 *
 * Blob references are used in AT Protocol to reference binary data stored
 * separately from records. They contain a CID, MIME type, and size information.
 *
 * @param options - Optional configuration for MIME type filtering and size limits
 * @returns A new {@link BlobSchema} instance
 *
 * @example
 * ```ts
 * // Basic blob reference
 * const fileSchema = l.blob()
 *
 * // Image files only
 * const imageSchema = l.blob({ accept: ['image/png', 'image/jpeg', 'image/gif'] })
 *
 * // Any image type with size limit
 * const avatarSchema = l.blob({ accept: ['image/*'], maxSize: 1000000 })
 *
 * // Allow legacy format
 * const legacySchema = l.blob({ allowLegacy: true })
 * ```
 */
exports.blob = (0, memoize_js_1.memoizedOptions)(function (options) {
    return new BlobSchema(options);
});
//# sourceMappingURL=blob.js.map