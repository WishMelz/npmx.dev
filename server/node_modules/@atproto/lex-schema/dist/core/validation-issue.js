"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IssueTooSmall = exports.IssueTooBig = exports.IssueRequiredKey = exports.IssueInvalidValue = exports.IssueInvalidType = exports.IssueInvalidFormat = exports.IssueCustom = exports.Issue = void 0;
const lex_data_1 = require("@atproto/lex-data");
/**
 * Abstract base class for all validation issues.
 *
 * An issue represents a single validation failure, containing:
 * - A code identifying the type of issue
 * - The path to the invalid value in the data structure
 * - The actual input value that failed validation
 *
 * Subclasses add specific properties relevant to each issue type and
 * implement the {@link toString} method for human-readable error messages.
 */
class Issue {
    code;
    path;
    input;
    constructor(code, path, input) {
        this.code = code;
        this.path = path;
        this.input = input;
    }
    /**
     * Converts the issue to a JSON-serializable object.
     *
     * @returns An object containing the issue code, path, and message
     */
    toJSON() {
        return {
            code: this.code,
            path: this.path,
            message: this.toString(),
        };
    }
}
exports.Issue = Issue;
/**
 * A custom validation issue with a user-defined message.
 *
 * Use this for validation rules that don't fit into the standard issue categories.
 */
class IssueCustom extends Issue {
    path;
    input;
    message;
    constructor(path, input, message) {
        super('custom', path, input);
        this.path = path;
        this.input = input;
        this.message = message;
    }
    toString() {
        return `${this.message}${stringifyPath(this.path)}`;
    }
}
exports.IssueCustom = IssueCustom;
/**
 * Issue for string values that don't match an expected format.
 *
 * Used for AT Protocol specific formats like DID, handle, NSID, AT-URI, etc.
 */
class IssueInvalidFormat extends Issue {
    format;
    message;
    constructor(path, input, format, message) {
        super('invalid_format', path, input);
        this.format = format;
        this.message = message;
    }
    toString() {
        return `Invalid ${this.formatDescription}${this.message ? ` (${this.message})` : ''}${stringifyPath(this.path)} (got ${stringifyValue(this.input)})`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            format: this.format,
        };
    }
    /** Returns a human-readable description of the expected format. */
    get formatDescription() {
        switch (this.format) {
            case 'at-identifier':
                return `AT identifier`;
            case 'did':
                return `DID`;
            case 'nsid':
                return `NSID`;
            case 'cid':
                return `CID string`;
            case 'tid':
                return `TID string`;
            case 'record-key':
                return `record key`;
            default:
                return this.format;
        }
    }
}
exports.IssueInvalidFormat = IssueInvalidFormat;
/**
 * Issue for values that have an unexpected type.
 *
 * This is one of the most common validation issues, occurring when the
 * runtime type of a value doesn't match the expected schema type.
 */
class IssueInvalidType extends Issue {
    expected;
    constructor(path, input, expected) {
        super('invalid_type', path, input);
        this.expected = expected;
    }
    toString() {
        return `Expected ${oneOf(this.expected.map(stringifyExpectedType))} value type${stringifyPath(this.path)} (got ${stringifyType(this.input)})`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            expected: this.expected,
        };
    }
}
exports.IssueInvalidType = IssueInvalidType;
/**
 * Issue for values that don't match any of the expected literal values.
 *
 * Used when a value must be one of a specific set of allowed values
 * (e.g., enum-like constraints).
 */
class IssueInvalidValue extends Issue {
    values;
    constructor(path, input, values) {
        super('invalid_value', path, input);
        this.values = values;
    }
    toString() {
        return `Expected ${oneOf(this.values.map(stringifyValue))}${stringifyPath(this.path)} (got ${stringifyValue(this.input)})`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            values: this.values,
        };
    }
}
exports.IssueInvalidValue = IssueInvalidValue;
/**
 * Issue for missing required object properties.
 */
class IssueRequiredKey extends Issue {
    key;
    constructor(path, input, key) {
        super('required_key', path, input);
        this.key = key;
    }
    toString() {
        return `Missing required key "${String(this.key)}"${stringifyPath(this.path)}`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            key: this.key,
        };
    }
}
exports.IssueRequiredKey = IssueRequiredKey;
/**
 * Issue for values that exceed a maximum constraint.
 */
class IssueTooBig extends Issue {
    maximum;
    type;
    actual;
    constructor(path, input, maximum, type, actual) {
        super('too_big', path, input);
        this.maximum = maximum;
        this.type = type;
        this.actual = actual;
    }
    toString() {
        return `${this.type} too big (maximum ${this.maximum})${stringifyPath(this.path)} (got ${this.actual})`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: this.type,
            maximum: this.maximum,
        };
    }
}
exports.IssueTooBig = IssueTooBig;
/**
 * Issue for values that are below a minimum constraint.
 */
class IssueTooSmall extends Issue {
    minimum;
    type;
    actual;
    constructor(path, input, minimum, type, actual) {
        super('too_small', path, input);
        this.minimum = minimum;
        this.type = type;
        this.actual = actual;
    }
    toString() {
        return `${this.type} too small (minimum ${this.minimum})${stringifyPath(this.path)} (got ${this.actual})`;
    }
    toJSON() {
        return {
            ...super.toJSON(),
            type: this.type,
            minimum: this.minimum,
        };
    }
}
exports.IssueTooSmall = IssueTooSmall;
// -----------------------------------------------------------------------------
// Helper functions for formatting error messages
// -----------------------------------------------------------------------------
function stringifyExpectedType(expected) {
    if (expected === '$typed') {
        return 'an object which includes the "$type" property';
    }
    return expected;
}
function stringifyPath(path) {
    return ` at ${buildJsonPath(path)}`;
}
function buildJsonPath(path) {
    return `$${path.map(toJsonPathSegment).join('')}`;
}
function toJsonPathSegment(segment) {
    if (typeof segment === 'number') {
        return `[${segment}]`;
    }
    else if (/^[a-zA-Z_$][a-zA-Z0-9_]*$/.test(segment)) {
        return `.${segment}`;
    }
    else {
        return `[${JSON.stringify(segment)}]`;
    }
}
function oneOf(arr) {
    if (arr.length === 0)
        return '';
    if (arr.length === 1)
        return arr[0];
    return `one of ${arr.slice(0, -1).join(', ')} or ${arr.at(-1)}`;
}
function stringifyType(value) {
    switch (typeof value) {
        case 'object':
            if (value === null)
                return 'null';
            if (Array.isArray(value))
                return 'array';
            if ((0, lex_data_1.ifCid)(value))
                return 'cid';
            if ((0, lex_data_1.isLegacyBlobRef)(value))
                return 'legacy-blob';
            if (value instanceof Date)
                return 'date';
            if (value instanceof RegExp)
                return 'regexp';
            if (value instanceof Map)
                return 'map';
            if (value instanceof Set)
                return 'set';
            return 'object';
        case 'number':
            if (Number.isInteger(value) && Number.isSafeInteger(value)) {
                return 'integer';
            }
            if (Number.isNaN(value)) {
                return 'NaN';
            }
            if (value === Infinity) {
                return 'Infinity';
            }
            if (value === -Infinity) {
                return '-Infinity';
            }
            return 'float';
        default:
            return typeof value;
    }
}
function stringifyValue(value) {
    switch (typeof value) {
        case 'bigint':
            return `${value}n`;
        case 'number':
        case 'string':
        case 'boolean':
            return JSON.stringify(value);
        case 'object':
            if (Array.isArray(value)) {
                return `[${stringifyArray(value, stringifyValue)}]`;
            }
            if ((0, lex_data_1.isPlainObject)(value)) {
                return `{${stringifyArray(Object.entries(value), stringifyObjectEntry)}}`;
            }
        // fallthrough
        default:
            return stringifyType(value);
    }
}
/*@__NO_SIDE_EFFECTS__*/
function stringifyObjectEntry([key, _value]) {
    return `${JSON.stringify(key)}: ...`;
}
/*@__NO_SIDE_EFFECTS__*/
function stringifyArray(arr, fn, n = 2) {
    return arr.slice(0, n).map(fn).join(', ') + (arr.length > n ? ', ...' : '');
}
//# sourceMappingURL=validation-issue.js.map