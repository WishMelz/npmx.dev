"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationContext = void 0;
const result_js_1 = require("./result.js");
const validation_error_js_1 = require("./validation-error.js");
const validation_issue_js_1 = require("./validation-issue.js");
/**
 * Manages the state and context for validation operations.
 *
 * The `ValidationContext` class is responsible for:
 * - Tracking the current path in nested structures for error reporting
 * - Collecting validation issues during traversal
 * - Enforcing validation mode (validate vs parse)
 * - Providing factory methods for creating validation results
 *
 * Use the static {@link ValidationContext.validate} method as the primary entry point
 * for validation. This ensures proper mode enforcement and issue aggregation.
 *
 * @example
 * ```typescript
 * // Primary usage via static method
 * const result = ValidationContext.validate(data, schema, { mode: 'parse' })
 *
 * // Within a custom validator implementation
 * class MyValidator implements Validator {
 *   validateInContext(input: unknown, ctx: ValidationContext): ValidationResult {
 *     if (typeof input !== 'string') {
 *       return ctx.issueUnexpectedType(input, 'string')
 *     }
 *     return ctx.success(input)
 *   }
 * }
 * ```
 */
class ValidationContext {
    options;
    static validate(input, validator, options) {
        const context = new ValidationContext({
            path: options?.path ?? [],
            mode: options?.mode ?? 'validate',
        });
        return context.validate(input, validator);
    }
    /**
     * The current path being validated, used for error reporting.
     */
    currentPath;
    /**
     * Accumulated validation issues collected during traversal.
     */
    issues = [];
    /**
     * Creates a new validation context with the specified options.
     *
     * @param options - The validation options (path and mode are required)
     */
    constructor(options) {
        this.options = options;
        // Create a copy because we will be mutating the array during validation.
        this.currentPath = Array.from(options.path);
    }
    /**
     * Returns a copy of the current validation path.
     *
     * The path represents the location in the data structure being validated,
     * used for constructing meaningful error messages.
     */
    get path() {
        return Array.from(this.currentPath);
    }
    /**
     * Creates a new path by appending segments to the current path.
     *
     * @param path - Optional path segment(s) to append
     * @returns A new path array with the segment(s) appended
     */
    concatPath(path) {
        if (path == null)
            return this.path;
        return this.currentPath.concat(path);
    }
    /**
     * Validates input against a validator within this context.
     *
     * This is the primary entry point for validation within a context. Always use
     * this method instead of calling {@link Validator.validateInContext} directly,
     * as this method enforces validation mode rules and handles transformation detection.
     *
     * @typeParam V - The validator type
     * @param input - The value to validate
     * @param validator - The validator to use
     * @returns A validation result with the validated value or error
     */
    validate(input, validator) {
        // This is the only place where validateInContext should be called.
        const result = validator.validateInContext(input, this);
        if (result.success) {
            if (this.issues.length > 0) {
                // Validator returned a success but issues were added via the context.
                // This means the overall validation failed.
                return (0, result_js_1.failure)(new validation_error_js_1.ValidationError(Array.from(this.issues)));
            }
            if (this.options.mode !== 'parse' && !Object.is(result.value, input)) {
                // If the value changed, it means that a default (or some other
                // transformation) was applied, meaning that the original value did
                // *not* match the (output) schema. When not in "parse" mode, we
                // consider this a failure.
                // This check is the reason why Validator.validateInContext should not
                // be used directly, and ValidatorContext.validate should be used
                // instead, even when delegating validation from one validator to
                // another.
                // This if block comes before the next one because 'this.issues' will
                // end-up being appended to the returned ValidationError (see the
                // "failure" method below), resulting in a more complete error report.
                return this.issueInvalidValue(input, [result.value]);
            }
        }
        return result;
    }
    /**
     * Validates a child property of an object within this context.
     *
     * This method automatically manages the path stack, pushing the property key
     * before validation and popping it afterward. Use this for validating object
     * properties to ensure proper path tracking in error messages.
     *
     * @typeParam I - The input object type
     * @typeParam K - The property key type
     * @typeParam V - The validator type
     * @param input - The parent object containing the property
     * @param key - The property key to validate
     * @param validator - The validator to use for the property value
     * @returns A validation result for the property value
     *
     * @example
     * ```typescript
     * // In a custom object validator
     * const result = ctx.validateChild(input, 'name', stringSchema)
     * // If validation fails, error path will include 'name'
     * ```
     */
    validateChild(input, key, validator) {
        // @NOTE we could add support for recursive schemas by keeping track of
        // "parent" objects in the context and checking for circular references
        // here. This would allow us to validate recursive structures without
        // hitting maximum call stack errors, and would also allow us to provide
        // better error messages for circular reference issues. However, this is not
        // a priority at the moment as recursive structures are not supported in
        // the context of AT Protocol lexicons, and we can always add this in the
        // future if needed.
        // Instead of creating a new context, we just push/pop the path segment.
        this.currentPath.push(key);
        try {
            return this.validate(input[key], validator);
        }
        finally {
            this.currentPath.length--;
        }
    }
    /**
     * Adds a validation issue to the context without immediately failing.
     *
     * Use this method to collect multiple issues during validation before
     * determining the final result. Issues added this way will be included
     * in the final error if validation fails.
     *
     * @param issue - The validation issue to add
     */
    addIssue(issue) {
        this.issues.push(issue);
    }
    /**
     * Creates a successful validation result with the given value.
     *
     * @typeParam V - The value type
     * @param value - The validated value
     * @returns A successful validation result
     */
    success(value) {
        return (0, result_js_1.success)(value);
    }
    /**
     * Creates a failed validation result with the given error.
     *
     * @param reason - The validation error
     * @returns A failed validation result
     */
    failure(reason) {
        return (0, result_js_1.failure)(reason);
    }
    /**
     * Creates a failed validation result from a single issue.
     *
     * Any previously accumulated issues in the context are included in the error.
     *
     * @param issue - The validation issue that caused the failure
     * @returns A failed validation result
     */
    issue(issue) {
        return this.failure(new validation_error_js_1.ValidationError([...this.issues, issue]));
    }
    /**
     * Creates a failure for an invalid value that doesn't match expected values.
     *
     * @param input - The actual value that was received
     * @param values - The expected valid values
     * @returns A failed validation result with an invalid value issue
     */
    issueInvalidValue(input, values) {
        return this.issue(new validation_issue_js_1.IssueInvalidValue(this.path, input, values));
    }
    /**
     * Creates a failure for an invalid type.
     *
     * @param input - The actual value that was received
     * @param expected - An array of expected type names
     * @returns A failed validation result with an invalid type issue
     */
    issueInvalidType(input, expected) {
        return this.issue(new validation_issue_js_1.IssueInvalidType(this.path, input, expected));
    }
    /**
     * Creates a failure for an invalid type.
     *
     * @param input - The actual value that was received
     * @param expected - The expected type name
     * @returns A failed validation result with an invalid type issue
     */
    issueUnexpectedType(input, expected) {
        return this.issueInvalidType(input, [expected]);
    }
    /**
     * Creates a failure for a missing required key in an object.
     *
     * @param input - The object missing the required key
     * @param key - The name of the required key
     * @returns A failed validation result with a required key issue
     */
    issueRequiredKey(input, key) {
        return this.issue(new validation_issue_js_1.IssueRequiredKey(this.path, input, key));
    }
    /**
     * Creates a failure for an invalid string format.
     *
     * @param input - The actual value that was received
     * @param format - The expected format name (e.g., 'did', 'handle', 'uri')
     * @param msg - Optional additional message describing the format error
     * @returns A failed validation result with an invalid format issue
     */
    issueInvalidFormat(input, format, msg) {
        return this.issue(new validation_issue_js_1.IssueInvalidFormat(this.path, input, format, msg));
    }
    /**
     * Creates a failure for a value that exceeds a maximum constraint.
     *
     * @param input - The actual value that was received
     * @param type - The type of measurement (e.g., 'string', 'array', 'bytes')
     * @param max - The maximum allowed value
     * @param actual - The actual measured value
     * @returns A failed validation result with a too big issue
     */
    issueTooBig(input, type, max, actual) {
        return this.issue(new validation_issue_js_1.IssueTooBig(this.path, input, max, type, actual));
    }
    /**
     * Creates a failure for a value that is below a minimum constraint.
     *
     * @param input - The actual value that was received
     * @param type - The type of measurement (e.g., 'string', 'array', 'bytes')
     * @param min - The minimum required value
     * @param actual - The actual measured value
     * @returns A failed validation result with a too small issue
     */
    issueTooSmall(input, type, min, actual) {
        return this.issue(new validation_issue_js_1.IssueTooSmall(this.path, input, min, type, actual));
    }
    /**
     * Creates a failure for an invalid property value within an object.
     *
     * This is a convenience method that automatically extracts the property value
     * and constructs the appropriate path.
     *
     * @typeParam I - The input object type
     * @param input - The object containing the invalid property
     * @param property - The property key with the invalid value
     * @param values - The expected valid values
     * @returns A failed validation result with an invalid value issue at the property path
     */
    issueInvalidPropertyValue(input, property, values) {
        const value = input[property];
        const path = this.concatPath(property);
        return this.issue(new validation_issue_js_1.IssueInvalidValue(path, value, values));
    }
    /**
     * Creates a failure for an invalid property type within an object.
     *
     * This is a convenience method that automatically extracts the property value
     * and constructs the appropriate path.
     *
     * @typeParam I - The input object type
     * @param input - The object containing the invalid property
     * @param property - The property key with the invalid type
     * @param expected - The expected type name
     * @returns A failed validation result with an invalid type issue at the property path
     */
    issueInvalidPropertyType(input, property, expected) {
        const value = input[property];
        const path = this.concatPath(property);
        return this.issue(new validation_issue_js_1.IssueInvalidType(path, value, [expected]));
    }
}
exports.ValidationContext = ValidationContext;
//# sourceMappingURL=validator.js.map