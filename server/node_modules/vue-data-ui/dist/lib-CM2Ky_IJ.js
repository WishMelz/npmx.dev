import { unref as it, isRef as ct, toRaw as Et } from "vue";
const At = "#COMP# dataset prop is either missing, undefined or empty.", yt = "#COMP# dataset is missing the '#ATTR#' attribute.", xt = "#COMP# dataset '#ATTR#' attribute cannot be empty.", bt = "#COMP# dataset #KEY# item at index #INDX# is missing the '#ATTR#' attribute.", Ct = "#COMP# : Chart could not be built. Dataset is not formatted correctly", Mt = "#COMP# : A wrong value was provided to the #ATTR# attribute (#KEY# is not a valid value).", $t = {
  dataset: At,
  datasetAttribute: yt,
  datasetAttributeEmpty: xt,
  datasetSerieAttribute: bt,
  notBuildable: Ct,
  attributeWrongValue: Mt
};
function cn(t, n, e, s, r, o = 1.99999, c = 2, i = 1.45, l = 360, a = 105.25, u = 0) {
  const { series: f } = t;
  if (!f || f.length === 0)
    return [];
  const h = f.reduce((p, m) => p + m.value, 0), d = [];
  let g = 0;
  for (let p = 0; p < f.length; p++) {
    const m = f[p].value, A = f.length === 1, F = A ? 1 : h > 0 ? m / h : 0, b = F * (Math.PI * o), L = (A ? 0.5 : h > 0 ? m / 2 / h : 0.5) * (Math.PI * c), { startX: N, startY: x, endX: $, endY: M, path: D } = tt(
      [n, e],
      [s, r],
      [g, b],
      a,
      l,
      c
    ), y = tt(
      [n, e],
      [s - u, r - u],
      [g, b],
      a,
      l,
      c,
      !0
    ), I = tt(
      [n, e],
      [s * i, r * i],
      [g, L],
      a,
      l,
      c
    );
    d.push({
      arcSlice: `${D} L ${y.startX} ${y.startY} ${y.path} L ${N} ${x}`,
      cx: E(n),
      cy: E(e),
      ...f[p],
      proportion: E(F),
      ratio: E(b),
      path: D.replaceAll("NaN", "0"),
      startX: E(N),
      startY: E(x),
      endX: E($),
      endY: E(M),
      separator: {
        x: y.startX,
        y: y.startY
      },
      firstSeparator: {
        x: Number(y.path.split(" ").at(-2)),
        y: Number(y.path.split(" ").at(-1))
      },
      center: I
    }), g += b;
  }
  return d;
}
function ut([t, n], [e, s]) {
  return [t + e, n + s];
}
function lt([[t, n], [e, s]], [r, o]) {
  return [t * r + n * o, e * r + s * o];
}
function Dt(t) {
  return [
    [Math.cos(t), -Math.sin(t)],
    [Math.sin(t), Math.cos(t)]
  ];
}
function tt([t, n], [e, s], [r, o], c, i = 360, l = 2, a = !1) {
  o = o % (l * Math.PI);
  const u = Dt(c), [f, h] = ut(
    lt(u, [
      e * Math.cos(r),
      s * Math.sin(r)
    ]),
    [t, n]
  ), [d, g] = ut(
    lt(u, [
      e * Math.cos(r + o),
      s * Math.sin(r + o)
    ]),
    [t, n]
  ), p = o > Math.PI ? 1 : 0, m = o > 0 ? a ? 0 : 1 : a ? 1 : 0;
  return {
    startX: E(a ? d : f),
    startY: E(a ? g : h),
    endX: E(a ? f : d),
    endY: E(a ? h : g),
    path: `M${E(a ? d : f)} ${E(a ? g : h)} A ${[
      E(e),
      E(s),
      E(c / (l * Math.PI) * i),
      E(p),
      E(m),
      E(a ? f : d),
      E(a ? h : g)
    ].join(" ")}`
  };
}
function St({ defaultConfig: t, userConfig: n }) {
  const e = { ...t };
  return Object.keys(e).forEach((s) => {
    if (Object.hasOwn(n, s)) {
      const r = n[s];
      r === null ? e[s] = null : ["boolean", "function"].includes(typeof r) ? e[s] = r : ["string", "number"].includes(typeof r) ? at(r) && (e[s] = r) : Array.isArray(e[s]) ? Bt({ userConfig: n, key: s }) && (e[s] = r) : Rt({ userConfig: n, key: s }) && (e[s] = St({
        defaultConfig: e[s],
        userConfig: r
      }));
    }
  }), Object.keys(n).forEach((s) => {
    if (!Object.hasOwn(e, s)) {
      const r = n[s];
      e[s] = r && typeof r == "object" && !Array.isArray(r) ? { ...r } : r;
    }
  }), e;
}
function Bt({ userConfig: t, key: n }) {
  return Object.hasOwn(t, n) && Array.isArray(t[n]) && t[n].length >= 0;
}
function Rt({ userConfig: t, key: n }) {
  return Object.hasOwn(t, n) && !Array.isArray(t[n]) && typeof t[n] == "object";
}
function at(t) {
  return ![null, void 0, NaN, 1 / 0, -1 / 0].includes(t);
}
function an(t) {
  return ![void 0, NaN, 1 / 0, -1 / 0].includes(t);
}
function un(t, n = 0) {
  return at(t) ? t : n;
}
function E(t, n = 0) {
  return isNaN(t) ? n : t;
}
const ft = [
  "#1f77b4",
  "#aec7e8",
  "#ff7f0e",
  "#ffbb78",
  "#2ca02c",
  "#98df8a",
  "#d62728",
  "#ff9896",
  "#9467bd",
  "#c5b0d5",
  "#8c564b",
  "#c49c94",
  "#e377c2",
  "#f7b6d2",
  "#7f7f7f",
  "#c7c7c7",
  "#bcbd22",
  "#dbdb8d",
  "#17becf",
  "#9edae5",
  "#393b79",
  "#5254a3",
  "#6b6ecf",
  "#9c9ede",
  "#637939",
  "#8ca252",
  "#b5cf6b",
  "#cedb9c",
  "#8c6d31",
  "#bd9e39",
  "#e7ba52",
  "#e7cb94",
  "#843c39",
  "#ad494a",
  "#d6616b",
  "#e7969c",
  "#7b4173",
  "#a55194",
  "#ce6dbd",
  "#de9ed6"
];
function ln(t = "default") {
  switch (t) {
    case "hack":
      return j.hack;
    case "zen":
      return j.zen;
    case "concrete":
      return j.concrete;
    case "celebration":
      return j.celebration;
    case "celebrationNight":
      return j.celebrationNight;
    case "minimal":
      return j.minimal;
    case "minimalDark":
      return j.minimalDark;
    default:
      return j.default;
  }
}
const j = {
  default: ft,
  dark: ft,
  minimal: [
    "#2A2929",
    "#454862",
    "#65698E",
    "#8D99AE",
    "#678681",
    "#7FA09B",
    "#9CBCA8",
    "#76645D",
    "#877675",
    "#A9998C",
    "#C6B7AB",
    "#906C70",
    "#B08C91",
    "#C9ACB0",
    "#9F816B",
    "#B39783",
    "#D8C3B3",
    "#825E76",
    "#9D7D92",
    "#C2A6B9"
  ],
  minimalDark: [
    "#524f4f",
    "#454862",
    "#65698E",
    "#8D99AE",
    "#678681",
    "#7FA09B",
    "#9CBCA8",
    "#76645D",
    "#877675",
    "#A9998C",
    "#C6B7AB",
    "#906C70",
    "#B08C91",
    "#C9ACB0",
    "#9F816B",
    "#B39783",
    "#D8C3B3",
    "#825E76",
    "#9D7D92",
    "#C2A6B9"
  ],
  celebration: [
    "#D32F2F",
    "#E64A19",
    "#F57C00",
    "#FF9800",
    "#FF5722",
    "#FFC107",
    "#FFEB3B",
    "#FFD54F",
    "#FF6F00",
    "#D84315",
    "#BF360C",
    "#C62828",
    "#B71C1C",
    "#FF7043",
    "#FF8A65",
    "#FFB74D",
    "#FFA726",
    "#FFCC80",
    "#FFE082",
    "#FFECB3"
  ],
  celebrationNight: [
    "#D32F2F",
    "#E64A19",
    "#F57C00",
    "#FF9800",
    "#FF5722",
    "#FFC947",
    "#FFEB3B",
    "#FFD95B",
    "#FF8800",
    "#FF5722",
    "#DD2C00",
    "#F44336",
    "#C62828",
    "#FF6E6E",
    "#FF867C",
    "#FFB547",
    "#FFA837",
    "#FFD180",
    "#FFE57F",
    "#FFF59D"
  ],
  concrete: [
    "#4A6A75",
    "#6C94A0",
    "#7DA9B5",
    "#8EBFCA",
    "#9FD4E0",
    "#B0E9F5",
    "#C1FFFF",
    "#5C6B5B",
    "#6D7D6D",
    "#7E8F7E",
    "#8FA290",
    "#A1B5A3",
    "#B2C7B5",
    "#C3DAC8",
    "#D4ECDA",
    "#E6FFF0",
    "#8A9CA5",
    "#9AA7B0",
    "#ABB1BC",
    "#BBCBC7",
    "#CCD6D3",
    "#DEE1DE",
    "#EFECEC",
    "#404C4D",
    "#50605F",
    "#617472",
    "#718885",
    "#829C98",
    "#92B0AB",
    "#A3C4BE",
    "#B3D8D2",
    "#C4EDE5",
    "#D4F1E8",
    "#404C5A",
    "#50606C",
    "#61747E",
    "#718890",
    "#829CA2",
    "#92B0B5"
  ],
  hack: [
    "#004C00",
    "#006600",
    "#008000",
    "#009900",
    "#00B300",
    "#00CC00",
    "#00E600",
    "#00FF00",
    "#33FF33",
    "#33E633",
    "#33CC33",
    "#33B333",
    "#339933",
    "#338033",
    "#336633",
    "#334C33",
    "#333333",
    "#00AF19",
    "#19E619",
    "#19CC19",
    "#19B319",
    "#199919",
    "#198019",
    "#196619",
    "#194C19",
    "#193319",
    "#191919",
    "#66FF66",
    "#66E666",
    "#66CC66",
    "#66B366",
    "#669966",
    "#668066",
    "#666666",
    "#4CFF4C",
    "#4CE64C",
    "#4CCC4C",
    "#4CB34C"
  ],
  zen: [
    "#B9B99D",
    "#E0CFC3",
    "#DFCA99",
    "#DCB482",
    "#C09E85",
    "#8F837A",
    "#858480",
    "#B0B9A8",
    "#606C5A",
    "#5E5E5E",
    "#4F5B75",
    "#647393",
    "#818EA9",
    "#9FA9BE",
    "#BBC4D3",
    "#DCDFE7",
    "#928A98",
    "#8A9892",
    "#B1A7AD",
    "#C5B8A7",
    "#EBD6CC",
    "#D7E0D2",
    "#E0D2D7",
    "#E0DBD2",
    "#D2E0DB",
    "#DBD2E0",
    "#C1B7A5",
    "#A5AFC1",
    "#E0DBD2",
    "#D2D7E0",
    "#F7EDE2",
    "#97ACB7",
    "#C4CBBC",
    "#C3C5C5",
    "#A0AC94"
  ]
}, ht = ["00", "03", "05", "08", "0A", "0D", "0F", "12", "14", "17", "1A", "1C", "1F", "21", "24", "26", "29", "2B", "2E", "30", "33", "36", "38", "3B", "3D", "40", "42", "45", "47", "4A", "4D", "4F", "52", "54", "57", "59", "5C", "5E", "61", "63", "66", "69", "6B", "6E", "70", "73", "75", "78", "7A", "7D", "80", "82", "85", "87", "8A", "8C", "8F", "91", "94", "96", "99", "9C", "9E", "A1", "A3", "A6", "A8", "AB", "AD", "B0", "B3", "B5", "B8", "BA", "BD", "BF", "C2", "C4", "C7", "C9", "CC", "CF", "D1", "D4", "D6", "D9", "DB", "DE", "E0", "E3", "E6", "E8", "EB", "ED", "F0", "F2", "F5", "F7", "FA", "FC", "FF"];
function mt(t) {
  const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, s = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)$/i, r = /^hsla?\((\d+),\s*([\d.]+)%,\s*([\d.]+)%(?:,\s*([\d.]+))?\)$/i, o = /^oklch\(\s*([\d.]+)%?\s*[, ]\s*([\d.]+)%?\s*[, ]\s*([\d.]+)(?:deg)?\s*(?:\/\s*([\d.]+%?)\s*)?\)$/i, c = /^lch\(/i;
  if (t == null || typeof t == "number" && isNaN(t))
    return null;
  if (t = ct?.(t) ? it(t) : t, t = Vt(t), Array.isArray(t)) {
    const [l, a, u, f = 1] = t;
    t = `rgba(${l},${a},${u},${f})`;
  } else if (typeof t == "object")
    if (Number.isFinite(t.r) && Number.isFinite(t.g) && Number.isFinite(t.b)) {
      const l = Number.isFinite(t.a) ? t.a : 1;
      t = `rgba(${t.r},${t.g},${t.b},${l})`;
    } else
      return null;
  else if (typeof t == "number") {
    const l = t >>> 0, a = l.toString(16).padStart(l <= 16777215 ? 6 : 8, "0");
    return `#${a.length === 6 ? a + "ff" : a}`;
  } else if (typeof t != "string")
    return null;
  if (t = t.trim(), c.test(t))
    return console.warn(
      "[convertColorToHex] lch() colors are not supported. Use oklch() instead."
    ), null;
  if (t.toLowerCase() === "transparent")
    return "#FFFFFF00";
  t = t.replace(e, (l, a, u, f, h) => `#${a}${a}${u}${u}${f}${f}${h ? h + h : ""}`);
  let i;
  if (i = t.match(n)) {
    const [, l, a, u, f] = i, h = f ? parseInt(f, 16) / 255 : 1;
    return `#${l}${a}${u}${G(Math.round(X(h) * 255))}`;
  }
  if (i = t.match(s)) {
    const [, l, a, u, f] = i, h = f ? parseFloat(f) : 1;
    return `#${G(l)}${G(a)}${G(u)}${G(Math.round(X(h) * 255))}`;
  }
  if (i = t.match(r)) {
    const [, l, a, u, f] = i, h = f ? parseFloat(f) : 1, [d, g, p] = Tt(Number(l), Number(a), Number(u));
    return `#${G(d)}${G(g)}${G(p)}${G(Math.round(X(h) * 255))}`;
  }
  if (i = t.match(o)) {
    const [, l, a, u, f] = i, h = Ot(l);
    if (h === null) return null;
    const d = wt(a);
    if (d === null) return null;
    const g = Pt(u);
    if (g === null) return null;
    const p = Lt(f);
    if (p === null) return null;
    const [m, A, F] = Nt(h, d, g);
    return `#${G(m)}${G(A)}${G(F)}${G(Math.round(X(p) * 255))}`;
  }
  return null;
}
function X(t) {
  return Number.isFinite(t) ? t < 0 ? 0 : t > 1 ? 1 : t : 0;
}
function nt(t) {
  return !Number.isFinite(t) || t < 0 ? 0 : t > 255 ? 255 : Math.round(t);
}
function et(t) {
  return t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055;
}
function Nt(t, n, e) {
  const s = (e % 360 + 360) % 360 * (Math.PI / 180), r = n * Math.cos(s), o = n * Math.sin(s);
  return It(t, r, o);
}
function It(t, n, e) {
  const s = t + 0.3963377774 * n + 0.2158037573 * e, r = t - 0.1055613458 * n - 0.0638541728 * e, o = t - 0.0894841775 * n - 1.291485548 * e, c = s * s * s, i = r * r * r, l = o * o * o;
  let a = 4.0767416621 * c - 3.3077115913 * i + 0.2309699292 * l, u = -1.2684380046 * c + 2.6097574011 * i - 0.3413193965 * l, f = -0.0041960863 * c - 0.7034186147 * i + 1.707614701 * l;
  a = X(a), u = X(u), f = X(f);
  const h = et(a) * 255, d = et(u) * 255, g = et(f) * 255;
  return [nt(h), nt(d), nt(g)];
}
function Lt(t) {
  if (t === void 0) return 1;
  if (typeof t == "string" && t.endsWith("%")) {
    const e = parseFloat(t);
    return Number.isFinite(e) ? X(e / 100) : null;
  }
  const n = parseFloat(t);
  return Number.isFinite(n) ? X(n) : null;
}
function Ot(t) {
  let n = Number(t);
  return Number.isFinite(n) ? (n > 1 && (n = n / 100), X(n)) : null;
}
function wt(t) {
  let n = Number(t);
  return Number.isFinite(n) ? (n > 1 && (n = n / 100), n < 0 ? 0 : n) : null;
}
function Pt(t) {
  const n = Number(t);
  return Number.isFinite(n) ? n : null;
}
function G(t) {
  const n = Number(t).toString(16);
  return n.length === 1 ? "0" + n : n;
}
function Tt(t, n, e, s = 1) {
  t /= 360, n /= 100, e /= 100;
  let r, o, c;
  if (n === 0)
    r = o = c = e;
  else {
    const i = (u, f, h) => (h < 0 && (h += 1), h > 1 && (h -= 1), h < 0.16666666666666666 ? u + (f - u) * 6 * h : h < 0.5 ? f : h < 0.6666666666666666 ? u + (f - u) * (0.6666666666666666 - h) * 6 : u), l = e < 0.5 ? e * (1 + n) : e + n - e * n, a = 2 * e - l;
    r = i(a, l, t + 1 / 3), o = i(a, l, t), c = i(a, l, t - 1 / 3);
  }
  return [
    Math.round(r * 255),
    Math.round(o * 255),
    Math.round(c * 255),
    s
  ];
}
function fn(t, n) {
  const e = t.length === 9 ? t.substring(0, 7) : t, s = t.length === 9 ? t.substring(7, 9) : null, r = (f) => ({
    r: parseInt(f.substring(1, 3), 16),
    g: parseInt(f.substring(3, 5), 16),
    b: parseInt(f.substring(5, 7), 16)
  }), o = ({ r: f, g: h, b: d }) => {
    f /= 255, h /= 255, d /= 255;
    const g = Math.max(f, h, d), p = Math.min(f, h, d);
    let m, A, F = (g + p) / 2;
    if (g === p)
      m = A = 0;
    else {
      const b = g - p;
      switch (A = F > 0.5 ? b / (2 - g - p) : b / (g + p), g) {
        case f:
          m = (h - d) / b + (h < d ? 6 : 0);
          break;
        case h:
          m = (d - f) / b + 2;
          break;
        case d:
          m = (f - h) / b + 4;
          break;
      }
      m /= 6;
    }
    return { h: m, s: A, l: F };
  }, c = ({ h: f, s: h, l: d }) => {
    let g, p, m;
    if (h === 0)
      g = p = m = d;
    else {
      const A = (S, L, N) => (N < 0 && (N += 1), N > 1 && (N -= 1), N < 0.16666666666666666 ? S + (L - S) * 6 * N : N < 0.5 ? L : N < 0.6666666666666666 ? S + (L - S) * (0.6666666666666666 - N) * 6 : S), F = d < 0.5 ? d * (1 + h) : d + h - d * h, b = 2 * d - F;
      g = A(b, F, f + 1 / 3), p = A(b, F, f), m = A(b, F, f - 1 / 3);
    }
    return {
      r: Math.round(g * 255),
      g: Math.round(p * 255),
      b: Math.round(m * 255)
    };
  }, i = r(e || "#000000"), l = o(i);
  l.h += n, l.h = (l.h + 1) % 1;
  const a = c(l);
  return `#${(a.r << 16 | a.g << 8 | a.b).toString(16).padStart(6, "0")}` + (s || "");
}
function kt({
  centerX: t,
  centerY: n,
  outerPoints: e,
  radius: s,
  rotation: r
}) {
  const o = Math.PI / e, c = r;
  let i = "";
  const l = [];
  for (let a = 0; a < e * 2; a += 1) {
    let u = t + Math.cos(a * o + c) * s, f = n + Math.sin(a * o + c) * s;
    i += `${u},${f} `, l.push({ x: u, y: f });
  }
  return {
    path: `M${i}Z`,
    coordinates: l
  };
}
function hn({
  plot: t,
  radius: n,
  sides: e,
  rotation: s = 0
}) {
  const r = t.x, o = t.y, c = e / 2;
  return kt({
    centerX: r,
    centerY: o,
    outerPoints: c,
    radius: n + 1,
    rotation: s
  });
}
function Yt({
  centerX: t,
  centerY: n,
  innerCirclePoints: e,
  innerRadius: s,
  outerRadius: r
}) {
  const o = Math.PI / e, c = 60, i = e * 2;
  let l = "";
  for (let a = 0; a < i; a += 1) {
    let f = a % 2 == 0 ? r : s, h = t + Math.cos(a * o + c) * f, d = n + Math.sin(a * o + c) * f;
    l += `${h},${d} `;
  }
  return l;
}
function dn({
  plot: t,
  radius: n,
  apexes: e = 5
}) {
  const s = t.x, r = t.y, o = e, c = n * 3.5 / o, l = c * 2;
  return Yt({
    centerX: s,
    centerY: r,
    innerCirclePoints: o,
    innerRadius: c,
    outerRadius: l
  });
}
function gn({ series: t }) {
  if (!Array.isArray(t) || t.length === 0) return "";
  const n = Array.from(
    new Map(
      t.filter((u) => u && Number.isFinite(u.x) && Number.isFinite(u.y)).map((u) => [`${u.x},${u.y}`, { x: +u.x, y: +u.y }])
    ).values()
  );
  if (n.length === 0) return "";
  if (n.length === 1) return `${Math.round(n[0].x)},${Math.round(n[0].y)} `;
  const e = (u, f) => {
    const h = u.x - f.x, d = u.y - f.y;
    return h * h + d * d;
  }, s = (u, f, h) => (f.x - u.x) * (h.y - u.y) - (f.y - u.y) * (h.x - u.x);
  let r = n[0];
  for (const u of n)
    (u.x < r.x || u.x === r.x && u.y < r.y) && (r = u);
  const o = [r];
  let c = r;
  const i = n.length + 2;
  let l = 0;
  for (; !(++l > i); ) {
    let u = n[0] === c ? n[1] : n[0];
    for (const f of n) {
      if (f === c || f === u) continue;
      const h = s(c, u, f);
      h < 0 || (h > 0 || e(c, f) > e(c, u)) && (u = f);
    }
    if (u === r) break;
    o.push(u), c = u;
  }
  let a = "";
  for (const u of o)
    a += `${Math.round(u.x)},${Math.round(u.y)} `;
  return a;
}
function W(t) {
  return t * Math.PI / 180;
}
function v(t, n, e) {
  return Math.min(Math.max(t, n), e);
}
function Ht(t) {
  const n = t.trim().match(/^rgba?\(\s*([+\-]?\d+)\s*,\s*([+\-]?\d+)\s*,\s*([+\-]?\d+)\s*(?:,\s*([+\-]?[\d.]+)\s*)?\)$/i);
  if (!n) return null;
  const e = v(Number.parseInt(n[1], 10), 0, 255), s = v(Number.parseInt(n[2], 10), 0, 255), r = v(Number.parseInt(n[3], 10), 0, 255), o = n[4] === void 0 ? 1 : v(Number.parseFloat(n[4]), 0, 1);
  return { red: e, green: s, blue: r, alpha: o };
}
function Ut(t) {
  const n = t.trim();
  if (!n.startsWith("#")) return null;
  const e = n.slice(1);
  if (e.length === 3) {
    const s = Number.parseInt(e[0] + e[0], 16), r = Number.parseInt(e[1] + e[1], 16), o = Number.parseInt(e[2] + e[2], 16);
    return { red: s, green: r, blue: o, alpha: 1 };
  }
  if (e.length === 6) {
    const s = Number.parseInt(e.slice(0, 2), 16), r = Number.parseInt(e.slice(2, 4), 16), o = Number.parseInt(e.slice(4, 6), 16);
    return { red: s, green: r, blue: o, alpha: 1 };
  }
  if (e.length === 8) {
    const s = Number.parseInt(e.slice(0, 2), 16), r = Number.parseInt(e.slice(2, 4), 16), o = Number.parseInt(e.slice(4, 6), 16), c = Number.parseInt(e.slice(6, 8), 16) / 255;
    return { red: s, green: r, blue: o, alpha: c };
  }
  return null;
}
function Gt(t) {
  const n = t.trim().match(
    /^oklch\(\s*([+\-]?[\d.]+%?)\s+([+\-]?[\d.]+)\s+([+\-]?[\d.]+)(?:\s*\/\s*([+\-]?[\d.]+%?))?\s*\)$/i
  );
  if (!n) return null;
  const e = n[1], s = n[2], r = n[3], o = n[4], c = e.endsWith("%") ? v(Number.parseFloat(e) / 100, 0, 1) : v(Number.parseFloat(e), 0, 1), i = Math.max(0, Number.parseFloat(s)), l = Number.parseFloat(r), a = o ? o.endsWith("%") ? v(Number.parseFloat(o) / 100, 0, 1) : v(Number.parseFloat(o), 0, 1) : 1, u = l * Math.PI / 180, f = i * Math.cos(u), h = i * Math.sin(u), d = c + 0.3963377774 * f + 0.2158037573 * h, g = c - 0.1055613458 * f - 0.0638541728 * h, p = c - 0.0894841775 * f - 1.291485548 * h, m = d * d * d, A = g * g * g, F = p * p * p;
  let b = 4.0767416621 * m - 3.3077115913 * A + 0.2309699292 * F, S = -1.2684380046 * m + 2.6097574011 * A - 0.3413193965 * F, L = -0.0041960863 * m - 0.7034186147 * A + 1.707614701 * F;
  b = v(b, 0, 1), S = v(S, 0, 1), L = v(L, 0, 1);
  const N = (x) => {
    const $ = x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 0.4166666666666667) - 0.055;
    return v(Math.round($ * 255), 0, 255);
  };
  return {
    red: N(b),
    green: N(S),
    blue: N(L),
    alpha: a
  };
}
function vt(t, n, e) {
  const s = t / 255, r = n / 255, o = e / 255, c = (u) => u <= 0.03928 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4), i = c(s), l = c(r), a = c(o);
  return 0.2126 * i + 0.7152 * l + 0.0722 * a;
}
function pn(t) {
  if (!t) return "#000000";
  const n = Ht(t), e = Ut(t), s = Gt(t), r = n ?? e ?? s;
  if (!r)
    return "#000000";
  const o = vt(r.red, r.green, r.blue);
  return (r.alpha < 1 ? r.alpha * o + (1 - r.alpha) * 1 : o) > 0.3 ? "#000000" : "#FFFFFF";
}
function z(t) {
  return t !== null && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && (t.constructor === Object || t.constructor == null);
}
function rt(t) {
  return !!t && (t.__v_isRef || t.__v_isReactive || t.__v_isReadonly || t.effect || t.dep || t.deps || t.subs);
}
function dt(t) {
  return t === "" ? "#000000" : t === "transparent" ? "#FFFFFF00" : mt(t) ?? t;
}
function st(t, n = /* @__PURE__ */ new WeakSet()) {
  const e = Et(t);
  if (!z(e) || n.has(e)) return e;
  n.add(e);
  for (const s in e) {
    const r = ct(e[s]) ? it(e[s]) : e[s];
    if (s === "color" || s === "backgroundColor") {
      typeof r == "string" && (e[s] = dt(r));
      continue;
    }
    if (s === "stroke") {
      typeof r == "string" ? e[s] = dt(r) : z(r) && !rt(r) && st(r, n);
      continue;
    }
    if (Array.isArray(r)) {
      for (const o of r)
        z(o) && !rt(o) && st(o, n);
      continue;
    }
    z(r) && !rt(r) && st(r, n);
  }
  return e;
}
function mn(t) {
  const n = t?.length ?? 0;
  if (n < 2) return { x1: 0, y1: 0, x2: 0, y2: 0, slope: 0, trend: 0 };
  let e = 0, s = 0, r = 0, o = 0;
  for (const { x: M, y: D } of t)
    e += M, s += D, r += M * D, o += M * M;
  const c = n * o - e * e || 1, i = (n * r - e * s) / c, l = (s - i * e) / n, a = t[0].x, u = t[n - 1].x, f = i * a + l, h = i * u + l;
  let d = 0, g = 0, p = 0, m = 0;
  for (let M = 0; M < n; M += 1)
    d += M, g += t[M].value, p += M * t[M].value, m += M * M;
  const A = n * m - d * d || 1, F = (n * p - d * g) / A, b = (g - F * d) / n, S = b, L = F * (n - 1) + b, x = Math.max(Math.abs(S), Math.abs(g / n), Math.abs(L), 1e-9), $ = (L - S) / x;
  return { x1: a, y1: f, x2: u, y2: h, slope: i, trend: $ };
}
function Fn(t) {
  const n = Math.floor(t.length / 2), e = [...t].sort((s, r) => s - r);
  return t.length % 2 !== 0 ? e[n] : (e[n - 1] + e[n]) / 2;
}
function En(t) {
  let n = [];
  for (let e = 0; e < t.length; e += 1)
    n.push(`${E(t[e].x)},${E(t[e].y)} `);
  return n.join(" ").trim();
}
function An(t) {
  if (t.length < 2) return "0,0";
  const n = t.length - 1, e = [`${E(t[0].x)},${E(t[0].y)}`], s = [], r = [], o = [], c = [];
  for (let i = 0; i < n; i += 1)
    s[i] = t[i + 1].x - t[i].x, r[i] = t[i + 1].y - t[i].y, o[i] = r[i] / s[i];
  c[0] = o[0], c[n] = o[n - 1];
  for (let i = 1; i < n; i += 1)
    if (o[i - 1] * o[i] <= 0)
      c[i] = 0;
    else {
      const l = 2 * o[i - 1] * o[i] / (o[i - 1] + o[i]);
      c[i] = l;
    }
  for (let i = 0; i < n; i += 1) {
    const l = t[i].x, a = t[i].y, u = t[i + 1].x, f = t[i + 1].y, h = c[i], d = c[i + 1], g = l + (u - l) / 3, p = a + h * (u - l) / 3, m = u - (u - l) / 3, A = f - d * (u - l) / 3;
    e.push(`C ${E(g)},${E(p)} ${E(m)},${E(A)} ${E(u)},${E(f)}`);
  }
  return e.join(" ");
}
function yn(t, n = 0.2) {
  function e(c, i) {
    const l = i.x - c.x, a = i.y - c.y;
    return {
      length: Math.sqrt(Math.pow(l, 2) + Math.pow(a, 2)),
      angle: Math.atan2(a, l)
    };
  }
  function s(c, i, l, a) {
    const h = e(i || c, l || c), d = h.angle + (a ? Math.PI : 0), g = h.length * n, p = c.x + Math.cos(d) * g, m = c.y + Math.sin(d) * g;
    return { x: p, y: m };
  }
  function r(c, i, l) {
    const a = s(l[i - 1], l[i - 2], c), u = s(c, l[i - 1], l[i + 1], !0);
    return `C ${E(a.x)},${E(a.y)} ${E(u.x)},${E(u.y)} ${E(c.x)},${E(c.y)}`;
  }
  return t.filter((c) => !!c).reduce(
    (c, i, l, a) => l === 0 ? `${E(i.x)},${E(i.y)} ` : `${c} ${r(i, l, a)} `,
    ""
  );
}
function xn() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
    const n = Math.random() * 16 | 0;
    return (t == "x" ? n : n & 3 | 8).toString(16);
  });
}
function _(t, n = !1, e = 16, s = !1) {
  let r = 0, o = n ? e : 0, c = s ? "center" : "middle";
  return t.center.endX > t.cx ? (r = t.center.endX + e + o, c = s ? "left" : "start") : t.center.endX < t.cx ? (r = t.center.endX - e - o, c = s ? "right" : "end") : (r = t.centerX + o, c = s ? "center" : "middle"), { x: r, anchor: c };
}
function Z(t, n = 16, e = 16) {
  return t.center.endY > t.cy ? t.center.endY + e : t.center.endY < t.cy ? t.center.endY - n : t.center.endY;
}
function bn({
  initX: t,
  initY: n,
  offset: e,
  centerX: s,
  centerY: r
}) {
  const o = Math.atan2(n - r, t - s);
  return {
    x: t + e * Math.cos(o),
    y: n + e * Math.sin(o)
  };
}
function Xt(t) {
  const n = document.createElementNS("http://www.w3.org/2000/svg", "path");
  n.setAttribute("d", t);
  const e = n.getTotalLength();
  let s = 0, r = e, o = e / 2;
  const c = 0.01;
  for (; r - s > c; ) {
    const a = (s + r) / 2, f = n.getPointAtLength(a).x;
    if (Math.abs(f - o) < c) {
      o = a;
      break;
    } else f < o ? s = a : r = a;
  }
  const { x: i, y: l } = n.getPointAtLength(o);
  return { x: i, y: l };
}
function Cn(t, n = !1, e = 16, s = 16, r = !1, o = !1, c = 0, i = 12, l = !1) {
  const { x: a } = Xt(t.path), u = `${_(t).x},${Z(t, e, s) - 4} `;
  let f = "", h, d;
  a > t.cx ? (h = _(t).x - i, d = Z(t, e, s) - 4, f = `${h},${d}`) : a < t.cx ? (h = _(t).x + i, d = Z(t, e, s) - 4, f = `${h},${d}`) : (h = _(t).x + i, d = Z(t, e, s) - 4, f = `${h},${d}`);
  const g = ` ${t.center.endX},${t.center.endY}`;
  return l ? o ? `M${f} Q${f} ${g}` : `M${u} Q${f} ${g}` : `M${o ? "" : u}${f}${g}`;
}
function Mn(t) {
  return ![null, void 0, NaN].includes(t);
}
function $n(t, n) {
  return [...t].map((e) => e[n]).reduce((e, s) => e + s, 0);
}
function Dn(t, n = !0, e = !1) {
  if (!t.length) return "M0,0";
  let s = "";
  return t.forEach((r) => {
    if (!r) return "";
    s += `${r.x},${r.y} `;
  }), e ? s.trim() : `M${s}${n ? "Z" : ""}`;
}
function Sn({ csvContent: t, title: n = "vue-data-ui" }) {
  const e = encodeURI(t), s = document.createElement("a");
  s.setAttribute("href", e), s.setAttribute("download", `${n}.csv`), document.body.appendChild(s), s.click(), s.remove(), window.URL.revokeObjectURL(e);
}
function Bn(t) {
  return `data:text/csv;charset=utf-8,${t.map((n) => n.join(",")).join(`
`)}`;
}
function Rn(t, n) {
  if (!/^#([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(t))
    return console.warn("lightenHexColor : Invalid hex color format"), "#000000";
  let e = t.replace("#", "");
  e.length === 3 && (e = e.split("").map((u) => u + u).join(""));
  const s = parseInt(e.substring(0, 2), 16), r = parseInt(e.substring(2, 4), 16), o = parseInt(e.substring(4, 6), 16), c = Math.min(255, s + (255 - s) * n), i = Math.min(255, r + (255 - r) * n), l = Math.min(255, o + (255 - o) * n), a = `#${Math.round(c).toString(16).padStart(2, "0")}${Math.round(i).toString(16).padStart(2, "0")}${Math.round(l).toString(16).padStart(2, "0")}`;
  if (e.length === 8) {
    const u = e.substring(6, 8);
    return a + u;
  }
  return a;
}
function Nn(t, n) {
  if (!/^#([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(t))
    return console.warn("darkenHexColor: Invalid hex color format"), "#000000";
  let e = t.replace("#", "");
  e.length === 3 && (e = e.split("").map((u) => u + u).join(""));
  const s = parseInt(e.substring(0, 2), 16), r = parseInt(e.substring(2, 4), 16), o = parseInt(e.substring(4, 6), 16), c = Math.max(0, s - s * n), i = Math.max(0, r - r * n), l = Math.max(0, o - o * n), a = `#${Math.round(c).toString(16).padStart(2, "0")}${Math.round(i).toString(16).padStart(2, "0")}${Math.round(l).toString(16).padStart(2, "0")}`;
  if (e.length === 8) {
    const u = e.substring(6, 8);
    return a + u;
  }
  return a;
}
function q(t, n) {
  const e = Math.floor(Math.log10(t)), s = t / Math.pow(10, e);
  let r;
  return n ? s < 1.5 ? r = 1 : s < 3 ? r = 2 : s < 7 ? r = 5 : r = 10 : s <= 1 ? r = 1 : s <= 2 ? r = 2 : s <= 5 ? r = 5 : r = 10, r * Math.pow(10, e);
}
function In(t, n, e, s = !1) {
  const r = s ? n - t : q(n - t, !1), o = s ? r / (e - 1) : q(r / (e - 1), !0), c = Math.floor(t / o) * o, i = Math.ceil(n / o) * o, l = [];
  for (let a = c; a <= i; a += o)
    l.push(a);
  return {
    min: c,
    max: i,
    tickSize: o,
    ticks: l
  };
}
function Ln(t, n, e, s = !1) {
  const r = s ? n - t : q(n - t, !1), o = s ? r / (e - 1) : q(r / (e - 1), !0), c = Math.floor(t / o) * o, i = Math.ceil(n / o) * o;
  let l = [], a = c;
  for (; a <= i; )
    a >= t && a <= n && l.push(a), a += o;
  return l[0] !== t && (l[0] = t), l[l.length - 1] !== n && (l[l.length - 1] = n), {
    min: t,
    max: n,
    tickSize: o,
    ticks: l
  };
}
function On(t, n, e, s, r) {
  const o = (h) => {
    let d = parseInt(h.substring(1, 3), 16), g = parseInt(h.substring(3, 5), 16), p = parseInt(h.substring(5, 7), 16), m = 1;
    return h.length === 9 && (m = parseInt(h.substring(7, 9), 16) / 255), { r: d, g, b: p, a: m };
  }, c = ({ r: h, g: d, b: g, a: p }) => {
    const m = (F) => F.toString(16).padStart(2, "0"), A = `#${m(h)}${m(d)}${m(g)}`;
    if (p !== 1) {
      const F = Math.round(p * 255).toString(16).padStart(2, "0");
      return A + F;
    }
    return A;
  }, i = o(t), l = o(n);
  r = Math.min(Math.max(r, e), s);
  const a = (r - e) / (s - e), u = {
    r: Math.round(i.r + (l.r - i.r) * a),
    g: Math.round(i.g + (l.g - i.g) * a),
    b: Math.round(i.b + (l.b - i.b) * a)
  }, f = i.a + (l.a - i.a) * a;
  return c({ ...u, a: f });
}
function wn({ p: t = "", v: n, s: e = "", r: s = 0, space: r = !1, isAnimating: o = !1, regex: c = /[^%]/g, replacement: i = "-", locale: l = null }) {
  const a = l ? Number(Number(n).toFixed(s)).toLocaleString(l) : Number(Number(n).toFixed(s)).toLocaleString(), u = a === 1 / 0 ? "∞" : a === -1 / 0 ? "-∞" : a, f = `${t ?? ""}${r ? " " : ""}${[void 0, null].includes(n) ? "-" : u}${r ? " " : ""}${e ?? ""}`;
  return o ? f.replace(c, i) : f;
}
function Pn({ source: t, length: n = 3 }) {
  if (!t && t !== 0)
    return "";
  t = String(t);
  const e = t.length > 1 ? t.split(" ") : [t];
  if (e.length === 1 && e[0].length === 1)
    return String(t).toUpperCase();
  if (e.length === 1)
    return t.slice(0, n).toUpperCase();
  {
    const s = [];
    return e.forEach((r, o) => {
      o < n && s.push(r.slice(0, 1));
    }), s.join().replaceAll(",", "").toUpperCase();
  }
}
function Tn(t) {
  return !!t && typeof t == "function";
}
function kn(t) {
  return typeof t.apply(null, arguments) == "string";
}
function Yn(t) {
  return Array.isArray(t) ? t.length === 0 : t ? Object.keys(t).length === 0 : !0;
}
function Hn({ componentName: t, type: n, property: e = "", index: s = "", key: r = "", warn: o = !0, debug: c = !0 }) {
  if (!c) return;
  const i = `
> ${$t[n].replace("#COMP#", t).replace("#ATTR#", e).replace("#INDX#", s).replace("#KEY#", r)}
`;
  if (o)
    console.warn(i);
  else
    throw new Error(i);
}
function jt({ points: t, a: n, b: e, angleStep: s, startX: r, startY: o }) {
  const c = [];
  for (let i = 0; i < t; i++) {
    const l = s * i, a = n + e * l, u = a * Math.cos(l) + r, f = a * Math.sin(l) + o;
    c.push({ x: u, y: f });
  }
  return c;
}
function Wt(t) {
  let n = 1 / 0, e = 1 / 0, s = -1 / 0, r = -1 / 0;
  for (const o of t)
    o.x < n && (n = o.x), o.y < e && (e = o.y), o.x > s && (s = o.x), o.y > r && (r = o.y);
  return { minX: n, minY: e, maxX: s, maxY: r, width: s - n || 1, height: r - e || 1 };
}
function Kt(t) {
  if (!t.length) return "";
  let n = `M${t[0].x} ${t[0].y}`;
  for (let e = 1; e < t.length - 2; e += 2) {
    const s = t[e - 1], r = t[e], o = t[e + 1], c = t[e + 2], i = (s.x + r.x) / 2, l = (s.y + r.y) / 2, a = (r.x + o.x) / 2, u = (r.y + o.y) / 2, f = (o.x + c.x) / 2, h = (o.y + c.y) / 2;
    n += ` C${i} ${l}, ${a} ${u}, ${f} ${h}`;
  }
  return n;
}
function Un({
  maxPoints: t,
  a: n = 6,
  b: e = 6,
  angleStep: s = 0.07,
  startX: r,
  startY: o,
  boxWidth: c,
  boxHeight: i,
  padding: l = 12
}) {
  const a = jt({ points: t, a: n, b: e, angleStep: s, startX: 0, startY: 0 }), { minX: u, minY: f, maxX: h, maxY: d, width: g, height: p } = Wt(a), m = (u + h) / 2, A = (f + d) / 2, F = Math.max(1, c - 2 * l), b = Math.max(1, i - 2 * l), S = Math.min(F / g, b / p), L = r - m * S, N = o - A * S;
  return function($) {
    const M = Math.max(2, Math.min(Math.round($), a.length)), D = a.slice(0, M).map((y) => ({ x: y.x * S + L, y: y.y * S + N }));
    return Kt(D);
  };
}
function Gn({ datasetObject: t, requiredAttributes: n }) {
  let e = [];
  return n.forEach((s) => {
    Object.hasOwn(t, s) || e.push(s);
  }), e;
}
const gt = {
  ALICEBLUE: "#F0F8FF",
  ANTIQUEWHITE: "#FAEBD7",
  AQUA: "#00FFFF",
  AQUAMARINE: "#7FFFD4",
  AZURE: "#F0FFFF",
  BEIGE: "#F5F5DC",
  BISQUE: "#FFE4C4",
  BLACK: "#000000",
  BLANCHEDALMOND: "#FFEBCD",
  BLUE: "#0000FF",
  BLUEVIOLET: "#8A2BE2",
  BROWN: "#A52A2A",
  BURLYWOOD: "#DEB887",
  CADETBLUE: "#5F9EA0",
  CHARTREUSE: "#7FFF00",
  CHOCOLATE: "#D2691E",
  CORAL: "#FF7F50",
  CORNFLOWERBLUE: "#6495ED",
  CORNSILK: "#FFF8DC",
  CRIMSON: "#DC143C",
  CYAN: "#00FFFF",
  DARKBLUE: "#00008B",
  DARKCYAN: "#008B8B",
  DARKGOLDENROD: "#B8860B",
  DARKGREY: "#A9A9A9",
  DARKGREEN: "#006400",
  DARKKHAKI: "#BDB76B",
  DARKMAGENTA: "#8B008B",
  DARKOLIVEGREEN: "#556B2F",
  DARKORANGE: "#FF8C00",
  DARKORCHID: "#9932CC",
  DARKRED: "#8B0000",
  DARKSALMON: "#E9967A",
  DARKSEAGREEN: "#8FBC8F",
  DARKSLATEBLUE: "#483D8B",
  DARKSLATEGREY: "#2F4F4F",
  DARKTURQUOISE: "#00CED1",
  DARKVIOLET: "#9400D3",
  DEEPPINK: "#FF1493",
  DEEPSKYBLUE: "#00BFFF",
  DIMGRAY: "#696969",
  DODGERBLUE: "#1E90FF",
  FIREBRICK: "#B22222",
  FLORALWHITE: "#FFFAF0",
  FORESTGREEN: "#228B22",
  FUCHSIA: "#FF00FF",
  GAINSBORO: "#DCDCDC",
  GHOSTWHITE: "#F8F8FF",
  GOLD: "#FFD700",
  GOLDENROD: "#DAA520",
  GREY: "#808080",
  GREEN: "#008000",
  GREENYELLOW: "#ADFF2F",
  HONEYDEW: "#F0FFF0",
  HOTPINK: "#FF69B4",
  INDIANRED: "#CD5C5C",
  INDIGO: "#4B0082",
  IVORY: "#FFFFF0",
  KHAKI: "#F0E68C",
  LAVENDER: "#E6E6FA",
  LAVENDERBLUSH: "#FFF0F5",
  LAWNGREEN: "#7CFC00",
  LEMONCHIFFON: "#FFFACD",
  LIGHTBLUE: "#ADD8E6",
  LIGHTCORAL: "#F08080",
  LIGHTCYAN: "#E0FFFF",
  LIGHTGOLDENRODYELLOW: "#FAFAD2",
  LIGHTGREY: "#D3D3D3",
  LIGHTGREEN: "#90EE90",
  LIGHTPINK: "#FFB6C1",
  LIGHTSALMON: "#FFA07A",
  LIGHTSEAGREEN: "#20B2AA",
  LIGHTSKYBLUE: "#87CEFA",
  LIGHTSLATEGREY: "#778899",
  LIGHTSTEELBLUE: "#B0C4DE",
  LIGHTYELLOW: "#FFFFE0",
  LIME: "#00FF00",
  LIMEGREEN: "#32CD32",
  LINEN: "#FAF0E6",
  MAGENTA: "#FF00FF",
  MAROON: "#800000",
  MEDIUMAQUAMARINE: "#66CDAA",
  MEDIUMBLUE: "#0000CD",
  MEDIUMORCHID: "#BA55D3",
  MEDIUMPURPLE: "#9370D8",
  MEDIUMSEAGREEN: "#3CB371",
  MEDIUMSLATEBLUE: "#7B68EE",
  MEDIUMSPRINGGREEN: "#00FA9A",
  MEDIUMTURQUOISE: "#48D1CC",
  MEDIUMVIOLETRED: "#C71585",
  MIDNIGHTBLUE: "#191970",
  MINTCREAM: "#F5FFFA",
  MISTYROSE: "#FFE4E1",
  MOCCASIN: "#FFE4B5",
  NAVAJOWHITE: "#FFDEAD",
  NAVY: "#000080",
  OLDLACE: "#FDF5E6",
  OLIVE: "#808000",
  OLIVEDRAB: "#6B8E23",
  ORANGE: "#FFA500",
  ORANGERED: "#FF4500",
  ORCHID: "#DA70D6",
  PALEGOLDENROD: "#EEE8AA",
  PALEGREEN: "#98FB98",
  PALETURQUOISE: "#AFEEEE",
  PALEVIOLETRED: "#D87093",
  PAPAYAWHIP: "#FFEFD5",
  PEACHPUFF: "#FFDAB9",
  PERU: "#CD853F",
  PINK: "#FFC0CB",
  PLUM: "#DDA0DD",
  POWDERBLUE: "#B0E0E6",
  PURPLE: "#800080",
  RED: "#FF0000",
  ROSYBROWN: "#BC8F8F",
  ROYALBLUE: "#4169E1",
  SADDLEBROWN: "#8B4513",
  SALMON: "#FA8072",
  SANDYBROWN: "#F4A460",
  SEAGREEN: "#2E8B57",
  SEASHELL: "#FFF5EE",
  SIENNA: "#A0522D",
  SILVER: "#C0C0C0",
  SKYBLUE: "#87CEEB",
  SLATEBLUE: "#6A5ACD",
  SLATEGREY: "#708090",
  SNOW: "#FFFAFA",
  SPRINGGREEN: "#00FF7F",
  STEELBLUE: "#4682B4",
  TAN: "#D2B48C",
  TEAL: "#008080",
  THISTLE: "#D8BFD8",
  TOMATO: "#FF6347",
  TURQUOISE: "#40E0D0",
  VIOLET: "#EE82EE",
  WHEAT: "#F5DEB3",
  WHITE: "#FFFFFF",
  WHITESMOKE: "#F5F5F5",
  YELLOW: "#FFFF00",
  YELLOWGREEN: "#9ACD32",
  REBECCAPURPLE: "#663399"
};
function Vt(t) {
  const n = ct?.(t) ? it(t) : t;
  if (typeof n != "string") return n;
  const e = n.trim();
  if (e === "" || e[0] === "#") return e;
  if (e.toLowerCase() === "transparent") return "#FFFFFF00";
  const s = e.toUpperCase(), r = s.replace(/GRAY/g, "GREY");
  return gt[s] || gt[r] || e;
}
const ot = "http://www.w3.org/2000/svg";
function vn(t) {
  if (t.length < 2)
    return 0;
  let n = 0, e = 0;
  for (let r = 1; r < t.length; r++) {
    const o = t[r - 1], c = t[r];
    if ([null, void 0, 0, 1 / 0, -1 / 0].includes(o))
      continue;
    const i = (c - o) / Math.abs(o) * 100;
    n += i, e++;
  }
  return e === 0 ? 0 : n / e;
}
function zt({
  content: t,
  fontSize: n,
  fill: e,
  x: s,
  y: r,
  translateY: o = !1
}) {
  const c = t.split(`
`), l = c.length * n, a = o ? (l - n) / 2 : 0;
  return c.map(
    (u, f) => `<tspan x="${s}" y="${r - a + f * n}" fill="${e}">${u}</tspan>`
  ).join("");
}
function Xn(t) {
  return at(t) ? (zt({
    content: t,
    fontSize: 1,
    fill: "",
    x: 0,
    y: 0
  }).match(/<tspan\b/g) || []).length : 1;
}
function jn({ content: t, fontSize: n, fill: e, x: s, autoOffset: r = !1 }) {
  const o = t.split(`
`), c = r ? (o.length - 1) * n / 2 : 0;
  return o.map((i, l) => {
    const a = l === 0 ? -c : n;
    return `<tspan x="${s}" dy="${a}" fill="${e}">${i}</tspan>`;
  }).join("");
}
function Wn({
  content: t,
  fontSize: n,
  fill: e,
  maxWords: s,
  x: r,
  y: o
}) {
  function c(a, u) {
    const f = a.split(" "), h = [];
    for (let d = 0; d < f.length; d += u)
      h.push(f.slice(d, d + u).join(" "));
    return h;
  }
  let i = "";
  return c(t, s).forEach((a, u) => {
    const f = `<tspan x="${r}" y="${o + u * n}" fill="${e}">${a}</tspan>`;
    i += f;
  }), i;
}
function Kn(t) {
  return t.length ? t.map((n) => mt(n)) : [];
}
function Vn(t, n = null) {
  const e = t.replace(/[\p{P}\p{S}]+/gu, " ").trim(), c = (/[\p{Script=Han}\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Hangul}\p{Script=Thai}\p{Script=Lao}\p{Script=Khmer}\p{Script=Tibetan}\p{Script=Myanmar}\p{Script=Devanagari}]/u.test(t) ? [...e] : e.split(/\s+/)).filter((i) => i.trim().length > 0).reduce((i, l) => (i[l] ? i[l] += 1 : i[l] = 1, i), {});
  return Object.keys(c).map((i) => {
    let l = i;
    return typeof n == "function" && typeof n(i) == "string" && (l = n(i)), {
      name: l,
      value: c[i]
    };
  });
}
function zn(t) {
  let n = t.reduce((i, l) => i + (l.stackRatio || 0), 0), e = t.filter((i) => i.stackRatio === void 0).length, s = 1 - n, r = e > 0 ? s / e : 0, o = t.map((i) => ({
    ...i,
    stackRatio: i.stackRatio !== void 0 ? i.stackRatio : r
  })), c = 0;
  return o = o.map((i, l) => (c += i.stackRatio, {
    ...i,
    stackIndex: l,
    cumulatedStackRatio: c
  })), o;
}
function _n(t) {
  function n(a, u, f, h) {
    const d = f - a, g = h - u;
    return Math.sqrt(d * d + g * g);
  }
  function e(a, u, f, h) {
    let g = 0, p = a.x, m = a.y;
    for (let A = 1; A <= 100; A += 1) {
      const F = A / 100, b = 1 - F, S = b * b, L = F * F, N = S * b * a.x + 3 * S * F * u.x + 3 * b * L * f.x + L * F * h.x, x = S * b * a.y + 3 * S * F * u.y + 3 * b * L * f.y + L * F * h.y;
      g += n(p, m, N, x), p = N, m = x;
    }
    return g;
  }
  const s = t.match(/[a-zA-Z][^a-zA-Z]*/g);
  let r = 0, o = 0, c = 0, i = 0, l = 0;
  return s.forEach((a) => {
    const u = a[0], f = a.slice(1).trim().split(/[\s,]+/).map(Number);
    let h = 0;
    switch (u) {
      case "M":
        for (r = f[h++], o = f[h++], c = r, i = o; h < f.length; )
          l += n(r, o, f[h], f[h + 1]), r = f[h++], o = f[h++];
        break;
      case "L":
        for (; h < f.length; )
          l += n(r, o, f[h], f[h + 1]), r = f[h++], o = f[h++];
        break;
      case "H":
        for (; h < f.length; )
          l += n(r, o, f[h], o), r = f[h++];
        break;
      case "V":
        for (; h < f.length; )
          l += n(r, o, r, f[h]), o = f[h++];
        break;
      case "C":
        for (; h < f.length; )
          l += e(
            { x: r, y: o },
            { x: f[h], y: f[h + 1] },
            { x: f[h + 2], y: f[h + 3] },
            { x: f[h + 4], y: f[h + 5] }
          ), r = f[h + 4], o = f[h + 5], h += 6;
        break;
      case "Z":
        l += n(r, o, c, i), r = c, o = i;
        break;
    }
  }), l;
}
function Zn({
  relator: t,
  adjuster: n,
  source: e,
  threshold: s = 0,
  fallback: r,
  max: o = 24
}) {
  const c = t / (n / e);
  return c > o ? o : c < s ? r : c;
}
function Qn(t) {
  return t.reduce((n, e) => (e.series.forEach((s, r) => {
    ![void 0, null, 1 / 0, -1 / 0].includes(s) && !isNaN(s) && (n[r] = (n[r] || 0) + s);
  }), n), []);
}
function _t(t, { value: n, config: e }) {
  let s = !1, r = n;
  if (typeof t == "function")
    try {
      r = t({ value: n, config: e }), ["number", "string"].includes(typeof r) ? s = !0 : r = n;
    } catch (o) {
      console.warn("Formatter could not be applied:", o), s = !1;
    }
  return {
    isValid: s,
    value: r
  };
}
function qn(t, n, e, s) {
  const { isValid: r, value: o } = _t(t, { value: n, config: s });
  return r ? o : e;
}
function Jn(t, n) {
  return n.split(".").every((e) => t !== null && typeof t == "object" && e in t ? (t = t[e], !0) : !1);
}
function te(t, n = [], e = !1) {
  function s(o) {
    return e && o === null ? null : typeof o == "string" && isNaN(Number(o)) || typeof o == "number" && isFinite(o) ? o : 0;
  }
  function r(o) {
    if (Array.isArray(o))
      return o.map((c) => r(c));
    if (typeof o == "object" && o !== null) {
      let c = { ...o };
      return n.forEach((i) => {
        c.hasOwnProperty(i) && ![
          "NAME",
          "name",
          "TITLE",
          "title",
          "DESCRIPTION",
          "description",
          "LABEL",
          "label",
          "TIME",
          "time",
          "PERIOD",
          "period",
          "MONTH",
          "month",
          "YEAR",
          "year",
          "MONTHS",
          "months",
          "YEARS",
          "years",
          "DAY",
          "day",
          "DAYS",
          "days",
          "HOUR",
          "hour",
          "HOURS",
          "hours"
        ].includes(i) && Array.isArray(c[i]) && (c[i] = r(c[i]));
      }), Object.fromEntries(
        Object.entries(c).map(([i, l]) => [i, r(l)])
      );
    } else
      return s(o);
  }
  return r(t);
}
function ne(t, n = 100) {
  return t.length === 9 ? t.substring(0, 7) + ht[n] : t + ht[n];
}
function ee({ series: t, center: n, maxRadius: e, hasGhost: s = !1 }) {
  const o = 360 / (t.length - (s ? 1 : 0));
  return t.map((i, l) => {
    const u = i * e, f = l * o, h = f + o, d = f + o / 2, g = W(f) - W(90), p = W(h) - W(90), m = W(d) - W(90), A = n.x + u * Math.cos(g), F = n.y + u * Math.sin(g), b = n.x + u * Math.cos(p), S = n.y + u * Math.sin(p), L = n.x + u * Math.cos(m), N = n.y + u * Math.sin(m);
    return {
      path: `
            M ${n.x} ${n.y} 
            L ${A} ${F} 
            A ${u} ${u} 0 0 1 ${b} ${S} 
            Z
        `.trim(),
      middlePoint: { x: L, y: N },
      radius: u
    };
  });
}
function re({ data: t, threshold: n }) {
  if (n >= t.length || n < 3)
    return t;
  const e = [], s = (t.length - 2) / (n - 2);
  let r = 0;
  e.push(t[r]);
  for (let o = 0; o < n - 2; o += 1) {
    const c = Math.floor((o + 1) * s) + 1, i = Math.min(Math.floor((o + 2) * s) + 1, t.length), l = t.slice(c, i);
    let a = 0, u = 0;
    for (const d of l)
      a += d.x, u += d.y;
    a /= l.length, u /= l.length;
    let f = -1, h = r;
    for (let d = c; d < i; d += 1) {
      const g = Math.abs(
        (t[r].x - a) * (t[d].y - t[r].y) - (t[r].x - t[d].x) * (u - t[r].y)
      );
      g > f && (f = g, h = d);
    }
    e.push(t[h]), r = h;
  }
  return e.push(t[t.length - 1]), e;
}
function se({ data: t, threshold: n }) {
  if (n >= t.length || n < 3)
    return t;
  const e = [], s = (t.length - 2) / (n - 2);
  let r = 0;
  e.push(t[r]);
  for (let o = 0; o < n - 2; o += 1) {
    const c = Math.floor((o + 1) * s) + 1, i = Math.min(Math.floor((o + 2) * s) + 1, t.length), l = t.slice(c, i), a = l.reduce((h, d) => h + d, 0) / l.length;
    let u = -1, f = r;
    for (let h = c; h < i; h += 1) {
      const d = Math.abs((t[r] - a) * (h - r));
      d > u && (u = d, f = h);
    }
    e.push(t[f]), r = f;
  }
  return e.push(t[t.length - 1]), e;
}
function oe({ data: t, threshold: n, key: e = "value" }) {
  if (n >= t.length || n < 3)
    return t;
  const s = [], r = (t.length - 2) / (n - 2);
  let o = 0;
  s.push(t[o]);
  for (let c = 0; c < n - 2; c += 1) {
    const i = Math.floor((c + 1) * r) + 1, l = Math.min(Math.floor((c + 2) * r) + 1, t.length), a = t.slice(i, l), u = a.reduce((d, g) => d + g[e], 0) / a.length;
    let f = -1, h = o;
    for (let d = i; d < l; d += 1) {
      const g = Math.abs((t[o][e] - u) * (d - o));
      g > f && (f = g, h = d);
    }
    s.push(t[h]), o = h;
  }
  return s.push(t[t.length - 1]), s;
}
function ie({ radius: t, centerX: n, centerY: e, percentage: s }) {
  s = Math.max(0, Math.min(1, s));
  const r = s * Math.PI, o = n - t, c = e, i = n - t * Math.cos(r), l = e - t * Math.sin(r);
  return `M ${n},${e} L ${o},${c} A ${t},${t} 0 0 1 ${i},${l} Z`.trim();
}
function ce({ svgElement: t, x: n, y: e, offsetY: s = 0, element: r }) {
  if (!t || !r) return { top: 0, left: 0 };
  const o = t.createSVGPoint();
  o.x = n, o.y = e;
  const c = o.matrixTransform(t.getScreenCTM()), i = t.getBoundingClientRect(), l = r.getBoundingClientRect();
  let a = 0, u = 0;
  return c.x - l.width / 2 < i.left ? a = 0 : c.x + l.width > i.right ? a = -l.width : a = -l.width / 2, c.y - s - l.height < i.top ? u = s : u = -l.height - s, {
    top: c.y + u,
    left: c.x + a
  };
}
function ae({ svgElement: t, x: n, y: e, element: s, position: r }) {
  if (!t || !s) return { top: 0, left: 0 };
  const o = t.createSVGPoint();
  o.x = n, o.y = e;
  const c = o.matrixTransform(t.getScreenCTM()), { height: i, width: l } = s.getBoundingClientRect();
  let a = r === "right" ? 0 : -l, u = -(i / 2);
  return {
    top: c.y + u,
    left: c.x + a
  };
}
function Q(t) {
  if (t === null || typeof t != "object")
    return t;
  if (t instanceof Date)
    return new Date(t.getTime());
  if (t instanceof RegExp)
    return new RegExp(t.source, t.flags);
  if (t instanceof Map) {
    const e = /* @__PURE__ */ new Map();
    for (const [s, r] of t.entries())
      e.set(s, Q(r));
    return e;
  }
  if (t instanceof Set) {
    const e = /* @__PURE__ */ new Set();
    for (const s of t.values())
      e.add(Q(s));
    return e;
  }
  if (Array.isArray(t))
    return t.map((e) => Q(e));
  const n = {};
  for (const e in t)
    Object.prototype.hasOwnProperty.call(t, e) && (n[e] = Q(t[e]));
  return n;
}
function Zt(t) {
  const n = [];
  let e = [];
  for (const s of t)
    !s || s.value == null || Number.isNaN(s.x) || Number.isNaN(s.y) ? (e.length && n.push(e), e = []) : e.push(s);
  return e.length && n.push(e), n;
}
function ue(t, n) {
  const e = t.filter((c) => !!c);
  if (!e[0]) return [-10, -10, "", -10, -10].toString();
  const s = { x: e[0].x, y: n }, r = { x: e.at(-1).x, y: n }, o = [];
  return e.forEach((c) => {
    o.push(`${c.x},${c.y} `);
  }), [s.x, s.y, ...o, r.x, r.y].toString();
}
function le(t, n) {
  if (!t[0]) return [-10, -10, "", -10, -10].toString();
  const e = Zt(t);
  return e.length ? e.map((s) => {
    const r = { x: s[0].x, y: n }, o = { x: s.at(-1).x, y: n }, c = [];
    return s.forEach((i) => {
      c.push(`${i.x},${i.y} `);
    }), [r.x, r.y, ...c, o.x, o.y].toString();
  }).join(";") : "";
}
function Qt(t) {
  const n = [];
  let e = [];
  for (const s of t)
    s.value == null || Number.isNaN(s.x) || Number.isNaN(s.y) ? (e.length > 1 && n.push(e), e = []) : e.push(s);
  return e.length > 1 && n.push(e), n;
}
function fe(t) {
  let n = "", e = !1;
  for (let s = 0; s < t.length; s++) {
    const r = t[s];
    if (!V(r))
      continue;
    const o = `${E(r.x)},${E(r.y)}`;
    if (!e)
      n += o, e = !0;
    else {
      const c = t[s - 1], i = V(c) ? "L" : "M";
      n += `${i}${o}`;
    }
    n += " ";
  }
  return n.trim();
}
function Ft(t) {
  const n = Number(t);
  return Number.isFinite(n) ? Math.trunc(n) : null;
}
function J(t) {
  return `${E(t.x)},${E(t.y)}`;
}
function he(t, n = []) {
  const e = Array.isArray(t) ? t : [], s = e.length, r = /* @__PURE__ */ new Set(), o = s - 1;
  for (const f of Array.isArray(n) ? n : []) {
    const h = Ft(f);
    h !== null && (h > 0 && r.add(h - 1), h < o && r.add(h));
  }
  const c = [];
  let i = [], l = !1, a = !1;
  const u = () => {
    i.length >= 2 && c.push({
      path: i.map((f, h) => h === 0 ? f : `L${f}`).join(" "),
      dashed: l
    }), i = [], a = !1;
  };
  for (let f = 0; f < s; f += 1) {
    const h = e[f];
    if (!V(h)) {
      u();
      continue;
    }
    const d = J(h);
    if (!a) {
      i = [d], a = !0;
      continue;
    }
    const g = e[f - 1];
    if (!V(g)) {
      u(), i = [d], a = !0;
      continue;
    }
    const p = r.has(f - 1);
    if (i.length === 1) {
      l = p, i.push(d);
      continue;
    }
    if (p !== l) {
      const m = J(g);
      u(), l = p, i = [m, d], a = !0;
    } else
      i.push(d);
  }
  return u(), c;
}
function de(t) {
  const n = Qt(t);
  if (!n.length) return "";
  let e = "";
  for (const [s, r] of n.entries()) {
    if (r.length < 2) continue;
    const o = r.length - 1, c = [], i = [], l = [], a = [];
    for (let u = 0; u < o; u += 1)
      c[u] = r[u + 1].x - r[u].x, i[u] = r[u + 1].y - r[u].y, l[u] = i[u] / c[u];
    a[0] = l[0], a[o] = l[o - 1];
    for (let u = 1; u < o; u += 1)
      if (l[u - 1] * l[u] <= 0)
        a[u] = 0;
      else {
        const f = 2 * l[u - 1] * l[u] / (l[u - 1] + l[u]);
        a[u] = f;
      }
    e += `${s === 0 ? "" : "M"}${E(r[0].x)},${E(r[0].y)} `;
    for (let u = 0; u < o; u += 1) {
      const f = r[u].x, h = r[u].y, d = r[u + 1].x, g = r[u + 1].y, p = a[u], m = a[u + 1], A = f + (d - f) / 3, F = h + p * (d - f) / 3, b = d - (d - f) / 3, S = g - m * (d - f) / 3;
      e += `C${E(A)},${E(F)} ${E(b)},${E(S)} ${E(d)},${E(g)} `;
    }
  }
  return e.trim();
}
function V(t) {
  return t != null && t.value != null && Number.isFinite(t.x) && Number.isFinite(t.y);
}
function qt(t, n) {
  const e = t - 1, s = /* @__PURE__ */ new Set(), r = Array.isArray(n) ? n : [];
  for (const o of r) {
    const c = Ft(o);
    c !== null && (c > 0 && s.add(c - 1), c < e && s.add(c));
  }
  return s;
}
function Jt(t) {
  const n = [];
  let e = [];
  for (let s = 0; s < t.length; s += 1) {
    const r = t[s];
    V(r) ? e.push(s) : (e.length > 1 && n.push(e), e = []);
  }
  return e.length > 1 && n.push(e), n;
}
function tn(t, n) {
  const e = n.map((a) => t[a]), s = e.length - 1, r = [], o = [], c = [], i = [];
  for (let a = 0; a < s; a += 1)
    r[a] = e[a + 1].x - e[a].x, o[a] = e[a + 1].y - e[a].y, c[a] = o[a] / r[a];
  i[0] = c[0], i[s] = c[s - 1];
  for (let a = 1; a < s; a += 1)
    c[a - 1] * c[a] <= 0 ? i[a] = 0 : i[a] = 2 * c[a - 1] * c[a] / (c[a - 1] + c[a]);
  const l = new Array(s);
  for (let a = 0; a < s; a += 1) {
    const u = e[a].x, f = e[a].y, h = e[a + 1].x, d = e[a + 1].y, g = i[a], p = i[a + 1], m = u + (h - u) / 3, A = f + g * (h - u) / 3, F = h - (h - u) / 3, b = d - p * (h - u) / 3;
    l[a] = `C${E(m)},${E(A)} ${E(F)},${E(b)} ${E(h)},${E(d)}`;
  }
  return {
    startCoord: J(e[0]),
    commands: l
  };
}
function nn(t) {
  const n = [];
  if (!t.length) return n;
  let e = 0, s = t[0];
  for (let r = 1; r < t.length; r += 1)
    t[r] !== s && (n.push({ startEdge: e, endEdge: r - 1, dashed: s }), e = r, s = t[r]);
  return n.push({ startEdge: e, endEdge: t.length - 1, dashed: s }), n;
}
function ge(t, n = []) {
  const e = Array.isArray(t) ? t : [];
  if (e.length < 2) return [];
  const s = qt(e.length, n), r = Jt(e);
  if (!r.length) return [];
  const o = [];
  for (const c of r) {
    const { startCoord: i, commands: l } = tn(
      e,
      c
    ), a = new Array(l.length);
    for (let f = 0; f < l.length; f += 1) {
      const h = c[f];
      a[f] = s.has(h);
    }
    const u = nn(a);
    for (const f of u) {
      const h = f.startEdge, d = h === 0 ? i : J(e[c[h]]), g = l.slice(f.startEdge, f.endEdge + 1), p = `${d} ${g.join(" ")}`.trim();
      o.push({ path: p, dashed: f.dashed });
    }
  }
  return o;
}
function pe(t, n, e = !1, s = !0) {
  function r(c) {
    const i = [];
    let l = [];
    for (const a of c)
      !a || a.value == null || Number.isNaN(a.x) || Number.isNaN(a.y) ? (l.length > 1 && i.push(l), l = []) : l.push(a);
    return l.length > 1 && i.push(l), i;
  }
  return (e ? r(t) : [t]).map((c) => {
    if (c.length < 2) return "";
    const i = c.length - 1, l = [], a = [], u = [], f = [];
    for (let d = 0; d < i; d += 1)
      l[d] = c[d + 1].x - c[d].x, a[d] = c[d + 1].y - c[d].y, u[d] = a[d] / l[d];
    f[0] = u[0], f[i] = u[i - 1];
    for (let d = 1; d < i; d += 1)
      if (u[d - 1] * u[d] <= 0)
        f[d] = 0;
      else {
        const g = 2 * u[d - 1] * u[d] / (u[d - 1] + u[d]);
        f[d] = g;
      }
    let h = `M${c[0].x},${n}`;
    h += ` L${c[0].x},${c[0].y}`;
    for (let d = 0; d < i; d += 1) {
      const g = c[d].x, p = c[d].y, m = c[d + 1].x, A = c[d + 1].y, F = f[d], b = f[d + 1], S = g + (m - g) / 3, L = p + F * (m - g) / 3, N = m - (m - g) / 3, x = A - b * (m - g) / 3;
      h += ` C${S},${L} ${N},${x} ${m},${A}`;
    }
    return h += ` L${c[i].x},${n} ${s ? "Z" : ""}`, h;
  }).filter(Boolean);
}
function me(t) {
  return t.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
function en(t) {
  return t && typeof t == "object" && !Array.isArray(t) && Object.keys(t).length === 0 ? null : t;
}
function pt(t) {
  if (Array.isArray(t))
    return t.map(pt);
  if (t && typeof t == "object" && !Array.isArray(t)) {
    const n = {};
    for (const e in t)
      Object.hasOwn(t, e) && (n[e] = pt(t[e]));
    return en(n);
  }
  return t;
}
function Fe(t) {
  return 1 - Math.pow(1 - t, 3);
}
function Ee({ values: t, config: n = {} }) {
  const {
    keepInvalid: e = !0,
    convertInvalidToZero: s = !1
  } = n, r = [];
  let o = 0, c = 0;
  function i(a) {
    return typeof a != "number" || !Number.isFinite(a);
  }
  function l(a) {
    o += a, c += 1, r.push(o / c);
  }
  for (const a of t)
    i(a) ? s && e ? l(0) : !s && e && r.push(a) : l(a);
  return r;
}
function Ae({ values: t, config: n = {} }) {
  const {
    keepInvalid: e = !0,
    convertInvalidToZero: s = !1
  } = n, r = [], o = [];
  function c(l) {
    return typeof l != "number" || !Number.isFinite(l);
  }
  function i(l) {
    o.push(l), o.sort((f, h) => f - h);
    const a = o.length, u = a >> 1;
    a % 2 === 1 ? r.push(o[u]) : r.push((o[u - 1] + o[u]) / 2);
  }
  for (const l of t)
    c(l) ? s && e ? i(0) : !s && e && r.push(l) : i(l);
  return r;
}
function ye({
  el: t,
  bounds: n,
  currentFontSize: e,
  minFontSize: s = 6,
  attempts: r = 200,
  padding: o = 1
}) {
  if (!t || !e) return 0;
  let c = e;
  t.setAttribute("font-size", c);
  const { x: i, y: l, width: a, height: u } = n, f = i + o, h = l + o, d = i + a - o, g = l + u - o;
  let p = t.getBBox();
  if (p.x >= f + o && p.y >= h + o && p.x + p.width <= d - o && p.y + p.height <= g - o)
    return c;
  let m = r;
  for (; m-- > 0 && c > s && (c--, t.setAttribute("font-size", c), p = t.getBBox(), !(p.x >= f + o && p.y >= h + o && p.x + p.width <= d - o && p.y + p.height <= g - o)); )
    ;
  return c < s && (c = 0, t.setAttribute("font-size", c)), c;
}
function xe({
  value: t,
  maxDecimals: n = 4,
  fallbackFormatter: e,
  removeTrailingZero: s = !0
}) {
  if (t === 0)
    return "0";
  const r = Math.abs(t);
  if (r >= 1 && typeof e == "function") {
    const i = e(t);
    return String(i);
  }
  let o;
  if (r < 1) {
    const i = Math.floor(Math.log10(r));
    o = Math.min(Math.max(1 - i, 1), n);
  } else
    o = n;
  let c = t.toFixed(o);
  return s && (c = c.replace(/(\.\d*?[1-9])0+$/, "$1").replace(/\.0+$/, "")), c;
}
function be(t) {
  const n = [];
  for (let e = 0; e < t; e += 1)
    n.push(e === 0 ? 0 : e === 1 ? 1 : n[e - 1] + n[e - 2]);
  return n;
}
function Ce(t, n = 20) {
  t = t.replace(/[\r\n]+/g, " ");
  const e = t.split(" ");
  let s = "", r = "";
  for (let o of e)
    (s + (s ? " " : "") + o).length <= n ? s += (s ? " " : "") + o : (s && (r += (r ? `
` : "") + s), s = o);
  return s && (r += (r ? `
` : "") + s), r;
}
function Me(t) {
  const {
    lineA: n,
    lineB: e,
    colorLineA: s,
    // fill when A is above
    colorLineB: r,
    // fill when B is above
    smoothA: o = !1,
    smoothB: c = !1,
    sampleStepPx: i = 2,
    cutNullValues: l = !0,
    // break across gaps
    merge: a = !0
    // merge into large polygons
  } = t || {};
  if (!Array.isArray(n) || !Array.isArray(e) || !n.length || !e.length)
    return [];
  const u = (x) => Number.isFinite(x);
  function f(x) {
    if (!l) return [x.filter((D) => D && u(D.x) && u(D.y))];
    const $ = [];
    let M = [];
    for (const D of x)
      D && u(D.x) && u(D.y) && D.value != null ? M.push({ x: D.x, y: D.y }) : (M.length > 1 && $.push(M), M = []);
    return M.length > 1 && $.push(M), $;
  }
  function h(x) {
    const $ = x.length - 1, M = new Array($), D = new Array($), y = new Array($), I = new Array(x.length);
    for (let C = 0; C < $; C += 1)
      M[C] = x[C + 1].x - x[C].x, D[C] = x[C + 1].y - x[C].y, y[C] = D[C] / M[C];
    I[0] = y[0], I[$] = y[$ - 1];
    for (let C = 1; C < $; C += 1)
      y[C - 1] * y[C] <= 0 ? I[C] = 0 : I[C] = 2 * y[C - 1] * y[C] / (y[C - 1] + y[C]);
    return I;
  }
  function d(x, $, M, D, y) {
    const I = x.x, C = $.x, w = x.y, B = $.y, P = C - I;
    if (P === 0) return w;
    const T = (y - I) / P, O = T * T, Y = O * T, H = 2 * Y - 3 * O + 1, R = Y - 2 * O + T, k = -2 * Y + 3 * O, U = Y - O;
    return H * w + R * (M * P) + k * B + U * (D * P);
  }
  function g(x, $) {
    const M = f(x);
    if (!M.length) return [];
    let D = 1 / 0, y = -1 / 0;
    for (const B of M)
      D = Math.min(D, B[0].x), y = Math.max(y, B[B.length - 1].x);
    if (!u(D) || !u(y) || y <= D) return [];
    const I = Math.max(1, i), C = [];
    for (let B = D; B <= y; B += I) C.push(B);
    C[C.length - 1] < y && C.push(y);
    const w = [];
    for (const B of C) {
      let P = null, T = !1;
      for (const O of M) {
        const Y = O.length - 1;
        if (!(B < O[0].x - 1e-9 || B > O[Y].x + 1e-9)) {
          for (let H = 0; H < Y; H += 1) {
            const R = O[H], k = O[H + 1];
            if (!(B + 1e-9 < R.x || B - 1e-9 > k.x)) {
              if ($) {
                const U = O.__tangents || (O.__tangents = h(O));
                P = d(R, k, U[H], U[H + 1], B);
              } else {
                const U = (B - R.x) / (k.x - R.x || 1);
                P = R.y + U * (k.y - R.y);
              }
              T = !0;
              break;
            }
          }
          if (T) break;
        }
      }
      P == null ? w.push({ x: B, y: null, hole: !0 }) : w.push({ x: B, y: P, hole: !1 });
    }
    return w;
  }
  function p(x, $, M) {
    return x + M * ($ - x);
  }
  function m(x, $) {
    const M = [], D = [], y = Math.min(x.length, $.length);
    for (let I = 0; I < y - 1; I += 1) {
      const C = x[I], w = x[I + 1], B = $[I], P = $[I + 1];
      if (M.push(C), D.push(B), C.hole || w.hole || B.hole || P.hole || C.y == null || w.y == null || B.y == null || P.y == null)
        continue;
      const T = C.y - B.y, O = w.y - P.y;
      if (T > 0 && O < 0 || T < 0 && O > 0) {
        const Y = T / (T - O), H = p(C.x, w.x, Y), R = p(C.y, w.y, Y), k = { x: H, y: R, hole: !1 }, U = { x: H, y: R, hole: !1 };
        M.push(k), D.push(U);
      }
    }
    return y > 0 && (M.push(x[y - 1]), D.push($[y - 1])), { A: M, B: D };
  }
  function A(x, $) {
    const M = [], D = Math.min(x.length, $.length);
    for (let y = 0; y < D - 1; y += 1) {
      const I = x[y], C = x[y + 1], w = $[y], B = $[y + 1];
      if (I.hole || C.hole || w.hole || B.hole || I.y == null || C.y == null || w.y == null || B.y == null) continue;
      const P = I.y - w.y, T = C.y - B.y, O = P <= 0 ? I : w, Y = T <= 0 ? C : B, H = T <= 0 ? B : C, R = P <= 0 ? w : I, k = P <= 0 ? s : r, U = [
        `M${O.x},${O.y}`,
        `L${Y.x},${Y.y}`,
        `L${H.x},${H.y}`,
        `L${R.x},${R.y}`,
        "Z"
      ].join(" ");
      M.push({ d: U, color: k });
    }
    return M;
  }
  function F(x, $) {
    const M = [], D = Math.min(x.length, $.length);
    if (D < 2) return M;
    let y = 0;
    for (; y < D - 1; ) {
      for (; y < D - 1; ) {
        const R = x[y], k = $[y], U = x[y + 1], K = $[y + 1];
        if (!R.hole && !k.hole && !U.hole && !K.hole && R.y != null && k.y != null && U.y != null && K.y != null) break;
        y += 1;
      }
      if (y >= D - 1) break;
      const I = y, C = Math.sign($[y].y - x[y].y || 0) || 1;
      for (y += 1; y < D - 1; ) {
        const R = x[y], k = $[y], U = x[y + 1], K = $[y + 1];
        if (R.hole || k.hole || U.hole || K.hole || R.y == null || k.y == null || U.y == null || K.y == null || (Math.sign(k.y - R.y || 0) || 1) !== C) break;
        y += 1;
      }
      const w = y + 0, B = C >= 0 ? x : $, P = C >= 0 ? $ : x, T = C >= 0 ? s : r, O = [];
      for (let R = I; R <= w; R += 1)
        O.push(`${B[R].x},${B[R].y}`);
      const Y = [];
      for (let R = w; R >= I; R -= 1)
        Y.push(`${P[R].x},${P[R].y}`);
      const H = `M${O[0]} L${O.slice(1).join(" L")} L${Y.join(" L")} Z`;
      M.push({ d: H, color: T });
    }
    return M;
  }
  const b = g(n, o), S = g(e, c), { A: L, B: N } = m(b, S);
  return a ? F(L, N) : A(L, N);
}
function $e(t, n, e = {}) {
  const r = { ...{ bubbles: !0, cancelable: !0, composed: !0 }, ...e }, o = /* @__PURE__ */ new Set([
    "click",
    "mousedown",
    "mouseup",
    "mousemove",
    "mouseover",
    "mouseout",
    "mouseenter",
    "mouseleave",
    "dblclick",
    "contextmenu"
  ]), c = /* @__PURE__ */ new Set([
    "keydown",
    "keyup",
    "keypress"
  ]);
  let i;
  if (o.has(n))
    i = new MouseEvent(n, r);
  else if (c.has(n))
    i = new KeyboardEvent(n, r);
  else if (n === "input")
    try {
      i = new InputEvent(n, r);
    } catch {
      i = new Event(n, r);
    }
  else n.startsWith("custom:") ? i = new CustomEvent(n, { ...r, detail: r.detail }) : i = new Event(n, r);
  return t.dispatchEvent(i), i;
}
function De(t, { delta: n = 1, delay: e = 20, disableTransitions: s = !0 } = {}) {
  if (!t || !(t instanceof HTMLElement)) return;
  const r = t.style, o = {
    width: r.width,
    height: r.height,
    transition: r.transition
  }, c = t.getBoundingClientRect(), i = c.width, l = c.height;
  s && (r.transition = "none");
  const a = (u) => /%|em|rem/.test(u);
  r.width = o.width && a(o.width) ? `calc(${o.width} + ${n}px)` : `${Math.max(0, i + n)}px`, r.height = o.height && a(o.height) ? `calc(${o.height} + ${n}px)` : `${Math.max(0, l + n)}px`, t.offsetWidth, setTimeout(() => {
    r.width = o.width, r.height = o.height, t.offsetWidth, requestAnimationFrame(() => {
      s && (r.transition = o.transition);
    });
  }, e);
}
function rn(t) {
  let n = null, e = null;
  return (...s) => {
    const r = JSON.stringify(s);
    return r === n || (n = r, e = t(...s)), e;
  };
}
const Se = rn((t, n, e, s, r, o, c, i) => {
  if (t)
    return s.length <= 2 ? s.map((F, b) => ({ text: F, absoluteIndex: b })) : s.map((F, b) => ({ text: b === 0 || b === s.length - 1 || c != null && b === c ? F : "", absoluteIndex: b }));
  if (!n)
    return s.map((A, F) => ({ text: A, absoluteIndex: F }));
  const l = Math.max(1, e || 1);
  if (i <= l)
    return s.map((A, F) => ({ text: A, absoluteIndex: F }));
  const a = [];
  for (let A = 0; A < s.length; A += 1) {
    const F = s[A] ?? "";
    if (!F) continue;
    const b = o + A - 1 >= 0 ? r[o + A - 1] ?? "" : null;
    F !== b && a.push(A);
  }
  if (!a.length)
    return s.map((A, F) => ({ text: "", absoluteIndex: F }));
  const u = a.length, f = l, h = Math.max(2, Math.min(f - 3, u)), d = Math.min(u, f + 3);
  let g = Math.min(f, u), p = 1 / 0;
  for (let A = h; A <= d; A += 1) {
    const F = (u - 1) % (A - 1), b = Math.abs(A - f), S = F * 10 + b;
    S < p && (p = S, g = A);
  }
  const m = /* @__PURE__ */ new Set();
  if (g <= 1)
    m.add(a[Math.round((u - 1) / 2)]);
  else {
    const A = (u - 1) / (g - 1);
    for (let F = 0; F < g; F += 1)
      m.add(a[Math.round(F * A)]);
  }
  return s.map((A, F) => ({
    text: m.has(F) ? A : "",
    absoluteIndex: F
  }));
});
function Be(t) {
  return String(t).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function Re(t) {
  return String(t).replaceAll("&", "&amp;").replaceAll('"', "&quot;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function Ne(t) {
  if (!t || typeof t != "string")
    return null;
  const n = document.createElementNS(ot, "svg");
  n.setAttribute("xmlns", ot);
  const e = document.createElementNS(ot, "path");
  e.setAttribute("d", t), n.appendChild(e);
  const s = e.getTotalLength(), r = e.getPointAtLength(s / 2);
  return { x: r.x, y: r.y };
}
function Ie(t, n = "(", e = ")") {
  return `${n}${t}${e}`;
}
function Le(t, n) {
  return n <= 1 ? "0%" : `${t * 100 / (n - 1)}%`;
}
export {
  Me as $,
  An as A,
  fe as B,
  En as C,
  $e as D,
  at as E,
  ce as F,
  Pn as G,
  Wn as H,
  Vn as I,
  xe as J,
  Ee as K,
  Ae as L,
  ln as M,
  In as N,
  Ln as O,
  an as P,
  un as Q,
  se as R,
  Se as S,
  zn as T,
  E as U,
  he as V,
  ge as W,
  ot as X,
  pe as Y,
  le as Z,
  ue as _,
  qn as a,
  kn as a0,
  Le as a1,
  zt as a2,
  ae as a3,
  Jn as a4,
  Zn as a5,
  cn as a6,
  Cn as a7,
  Z as a8,
  _ as a9,
  De as aA,
  ht as aB,
  oe as aC,
  be as aD,
  Ne as aE,
  te as aa,
  Mn as ab,
  $n as ac,
  pt as ad,
  Un as ae,
  bn as af,
  ie as ag,
  Q as ah,
  Dn as ai,
  Fe as aj,
  _n as ak,
  re as al,
  gn as am,
  yn as an,
  vn as ao,
  On as ap,
  Fn as aq,
  Xn as ar,
  Qn as as,
  jn as at,
  me as au,
  Ce as av,
  ee as aw,
  Xt as ax,
  Re as ay,
  Be as az,
  dn as b,
  xn as c,
  wn as d,
  hn as e,
  ye as f,
  Hn as g,
  fn as h,
  j as i,
  ft as j,
  Kn as k,
  Gn as l,
  mt as m,
  mn as n,
  Yn as o,
  Ie as p,
  Rn as q,
  Sn as r,
  ne as s,
  St as t,
  Nn as u,
  Bn as v,
  st as w,
  pn as x,
  Tn as y,
  de as z
};
