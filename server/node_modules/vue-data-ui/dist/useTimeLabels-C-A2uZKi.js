function q(u) {
  return String(u || "").toLowerCase();
}
function B(u) {
  const o = (r, l, k) => {
    const m = new Intl.DateTimeFormat(u, { [l]: k });
    return Array.from({ length: r }, (A, d) => {
      const C = l === "month" ? new Date(2025, d, 1) : new Date(2025, 0, 5 + d);
      return m.format(C);
    });
  };
  return {
    months: o(12, "month", "long"),
    shortMonths: o(12, "month", "short"),
    days: o(7, "weekday", "long"),
    shortDays: o(7, "weekday", "short")
  };
}
const E = /* @__PURE__ */ new Map();
async function W(u) {
  const o = q(u) || "en";
  return E.has(o) || E.set(o, B(o)), { key: o, data: E.get(o) };
}
function G({
  useUTC: u = !1,
  min: o = void 0,
  max: r = void 0,
  locale: l = {
    months: [],
    shortMonths: [],
    days: [],
    shortDays: []
  },
  januaryAsYear: k = !1
}) {
  const m = [2, 4, 6, 9, 11], A = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  function d(e) {
    return e % 12;
  }
  function C(e) {
    return typeof e == "number" ? !0 : !isNaN(M(e));
  }
  function I(e) {
    const t = Date.parse(e);
    if (isNaN(t))
      return e;
    if (!u)
      return t;
    const s = String(e).replace(/([+-]\d{2}:\d{2}|Z)$/, "");
    return Date.parse(s + "Z");
  }
  function D(e) {
    return new Date(e);
  }
  function M(e) {
    const t = Date.parse(e);
    if (!isNaN(t))
      return I(e);
    const s = Date.parse(
      e.replace(/-/g, "/").replace(/[a-z]+/gi, " ")
    );
    return I(s);
  }
  function F(e) {
    return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  }
  function g(e, t) {
    const s = u, c = [
      "yyyy",
      "yy",
      "y",
      "MMMM",
      "MMM",
      "MM",
      "M",
      "dddd",
      "ddd",
      "dd",
      "d",
      "HH",
      "H",
      "hh",
      "h",
      "mm",
      "m",
      "ss",
      "s",
      "fff",
      "ff",
      "f",
      "TT",
      "T",
      "tt",
      "t",
      "K"
    ], i = new RegExp(
      `\\\\(${c.join("|")})`,
      "g"
    ), n = [];
    t = t.replace(i, (N, b) => (n.push(b), `{{${n.length - 1}}}`));
    const p = ["\0", ...l.months], $ = ["", ...l.shortMonths], U = ["", ...l.days], R = ["", ...l.shortDays];
    function h(N, b = 2) {
      let z = String(N);
      for (; z.length < b; ) z = "0" + z;
      return z;
    }
    const _ = s ? e.getUTCFullYear() : e.getFullYear();
    t = t.replace(/(^|[^\\])yyyy+/g, `$1${_}`).replace(/(^|[^\\])yy/g, `$1${String(_).substr(2, 2)}`).replace(/(^|[^\\])y/g, `$1${_}`);
    const x = (s ? e.getUTCMonth() : e.getMonth()) + 1;
    k && x === 1 && (p[1] = String(_), $[1] = String(_)), t = t.replace(/(^|[^\\])MMMM+/g, `$1${p[0]}`).replace(/(^|[^\\])MMM/g, `$1${$[0]}`).replace(/(^|[^\\])MM/g, `$1${h(x)}`).replace(/(^|[^\\])M/g, `$1${x}`);
    const j = s ? e.getUTCDate() : e.getDate();
    t = t.replace(/(^|[^\\])dddd+/g, `$1${U[0]}`).replace(/(^|[^\\])ddd/g, `$1${R[0]}`).replace(/(^|[^\\])dd/g, `$1${h(j)}`).replace(/(^|[^\\])d/g, `$1${j}`);
    const T = s ? e.getUTCHours() : e.getHours();
    t = t.replace(/(^|[^\\])HH+/g, `$1${h(T)}`).replace(/(^|[^\\])H/g, `$1${T}`);
    const K = T > 12 ? T - 12 : T === 0 ? 12 : T;
    t = t.replace(/(^|[^\\])hh+/g, `$1${h(K)}`).replace(/(^|[^\\])h/g, `$1${K}`);
    const P = s ? e.getUTCMinutes() : e.getMinutes();
    t = t.replace(/(^|[^\\])mm+/g, `$1${h(P)}`).replace(/(^|[^\\])m/g, `$1${P}`);
    const V = s ? e.getUTCSeconds() : e.getSeconds();
    t = t.replace(/(^|[^\\])ss+/g, `$1${h(V)}`).replace(/(^|[^\\])s/g, `$1${V}`);
    let w = s ? e.getUTCMilliseconds() : e.getMilliseconds();
    t = t.replace(/(^|[^\\])fff+/g, `$1${h(w, 3)}`), w = Math.round(w / 10), t = t.replace(/(^|[^\\])ff/g, `$1${h(w)}`), w = Math.round(w / 10), t = t.replace(/(^|[^\\])f/g, `$1${w}`);
    const L = T < 12 ? "AM" : "PM";
    t = t.replace(/(^|[^\\])TT+/g, `$1${L}`).replace(/(^|[^\\])T/g, `$1${L.charAt(0)}`).replace(/(^|[^\\])tt+/g, `$1${L.toLowerCase()}`).replace(/(^|[^\\])t/g, `$1${L.toLowerCase().charAt(0)}`);
    let H = -e.getTimezoneOffset(), Z = s || !H ? "Z" : H > 0 ? "+" : "-";
    if (!s) {
      H = Math.abs(H);
      const N = Math.floor(H / 60), b = H % 60;
      Z += h(N) + ":" + h(b);
    }
    t = t.replace(/(^|[^\\])K/g, `$1${Z}`);
    const v = (s ? e.getUTCDay() : e.getDay()) + 1;
    return t = t.replace(new RegExp(U[0], "g"), U[v]).replace(new RegExp(R[0], "g"), R[v]).replace(new RegExp(p[0], "g"), p[x]).replace(new RegExp($[0], "g"), $[x]), t = t.replace(/{{(\d+)}}/g, (N, b) => n[+b]), t;
  }
  function Y(e, t) {
    o !== void 0 && (e = o), r !== void 0 && (t = r);
    const s = D(e), c = D(t), i = g(s, "yyyy MM dd HH mm ss fff").split(" "), n = g(c, "yyyy MM dd HH mm ss fff").split(" ");
    return {
      minMillisecond: parseInt(i[6], 10),
      maxMillisecond: parseInt(n[6], 10),
      minSecond: parseInt(i[5], 10),
      maxSecond: parseInt(n[5], 10),
      minMinute: parseInt(i[4], 10),
      maxMinute: parseInt(n[4], 10),
      minHour: parseInt(i[3], 10),
      maxHour: parseInt(n[3], 10),
      minDate: parseInt(i[2], 10),
      maxDate: parseInt(n[2], 10),
      minMonth: parseInt(i[1], 10) - 1,
      maxMonth: parseInt(n[1], 10) - 1,
      minYear: parseInt(i[0], 10),
      maxYear: parseInt(n[0], 10)
    };
  }
  function y(e) {
    return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
  }
  function O(e, t, s) {
    return S(e, t) - s;
  }
  function a(e) {
    return y(e) ? 366 : 365;
  }
  function f(e, t, s) {
    let c = A[t] + s;
    return t > 1 && y(e) && (c += 1), c;
  }
  function S(e, t) {
    return e = d(e), m.includes(e) ? e === 2 ? y(t) ? 29 : 28 : 30 : 31;
  }
  return {
    isValidDate: C,
    getTimeStamp: I,
    getDate: D,
    parseDate: M,
    parseDateWithTimezone: F,
    formatDate: g,
    getTimeUnitsfromTimestamp: Y,
    isLeapYear: y,
    calculateLastDaysOfMonth: O,
    determineDaysOfYear: a,
    determineRemainingDaysOfYear: f,
    determineDaysOfMonths: S
  };
}
const J = 1440 * 60;
async function Q({
  values: u,
  maxDatapoints: o,
  formatter: r,
  start: l,
  end: k
}) {
  const m = [];
  if (!r.enable || u.length === 0) {
    for (let c = l; c < k; c += 1)
      m.push({ text: String(u[c] ?? c), absoluteIndex: c });
    return m;
  }
  const d = u.map((c) => {
    const i = new Date(c).getTime();
    return isNaN(i) ? c : i;
  }).slice(l, k);
  if (d.length === 0) return [];
  const C = d[0], I = d[d.length - 1];
  let D;
  try {
    ({ data: D } = await W(r.locale));
  } catch {
    ({ data: D } = await W("en"));
  }
  const M = G({
    useUTC: r.useUTC,
    min: C,
    max: I,
    locale: D,
    januaryAsYear: r.januaryAsYear
  }), g = (I - C) / (1e3 * J), Y = g * 24, y = Y * 60, O = y * 60;
  let a;
  switch (!0) {
    case g / 365 > 5:
      a = "years";
      break;
    case g > 800:
      a = "half_year";
      break;
    case g > 180:
      a = "months";
      break;
    case g > 90:
      a = "months_fortnight";
      break;
    case g > 60:
      a = "months_days";
      break;
    case g > 30:
      a = "week_days";
      break;
    case g > 2:
      a = "days";
      break;
    case Y > 2.4:
      a = "hours";
      break;
    case y > 15:
      a = "minutes_fives";
      break;
    case y > 5:
      a = "minutes";
      break;
    case y > 1:
      a = "seconds_tens";
      break;
    case O > 20:
      a = "seconds_fives";
      break;
    default:
      a = "seconds";
      break;
  }
  let f;
  a === "years" ? f = "year" : ["half_year", "months", "months_fortnight", "months_days", "week_days"].includes(a) ? f = "month" : a === "days" ? f = "day" : a === "hours" ? f = "hour" : ["minutes_fives", "minutes"].includes(a) ? f = "minute" : f = "second";
  const S = r.options[f] ?? r.options.hour, e = r.options.year, t = r.options.month, s = r.options.day;
  return d.forEach((c, i) => {
    const n = new Date(c);
    let p;
    switch (f) {
      case "year":
        p = M.formatDate(n, e);
        break;
      case "month": {
        const $ = r.useUTC ? n.getUTCMonth() : n.getMonth();
        p = r.januaryAsYear && $ === 0 ? M.formatDate(n, e) : M.formatDate(n, t);
        break;
      }
      case "day":
        p = M.formatDate(n, s);
        break;
      default: {
        const $ = r.useUTC ? n.getUTCHours() : n.getHours(), U = r.useUTC ? n.getUTCMinutes() : n.getMinutes();
        $ === 0 && U === 0 ? p = M.formatDate(n, s) : p = M.formatDate(n, S);
      }
    }
    m.push({ text: p, absoluteIndex: l + i });
  }), m;
}
export {
  W as a,
  G as b,
  Q as u
};
