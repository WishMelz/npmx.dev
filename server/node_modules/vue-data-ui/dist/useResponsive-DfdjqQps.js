function m(e, i, t, o = {}) {
  if (t <= 0) return;
  e.save();
  const {
    color: a = "black",
    lineWidth: w = 1,
    lineCap: h = "round",
    lineJoin: u = "round",
    lineDash: y = null,
    lineDashoffset: s = 0,
    shadowColor: l = null,
    shadowBlur: f = 0,
    shadowOffsetX: g = 0,
    shadowOffsetY: r = 0,
    fillStyle: N = "#FFFFFF"
  } = o;
  e.beginPath(), e.arc(i.x, i.y, t, 0, 2 * Math.PI), e.strokeStyle = a, e.lineWidth = w, e.lineCap = h, e.lineJoin = u, y && (e.setLineDash(y), e.lineDashoffset = s), l && (e.shadowColor = l, e.shadowOffsetX = g, e.shadowOffsetY = r), f && (e.shadowBlur = f), N && (e.fillStyle = N), e.fillStyle && e.fill(), e.stroke(), e.restore();
}
function L(e, i, t = {}) {
  if (!i.length) return;
  e.save();
  const {
    color: o = "black",
    lineWidth: a = 1,
    lineCap: w = "round",
    lineJoin: h = "round",
    lineDash: u = null,
    lineDashoffset: y = 0,
    shadowColor: s = null,
    shadowBlur: l = 0,
    shadowOffsetX: f = 0,
    shadowOffsetY: g = 0
  } = t;
  e.beginPath(), e.moveTo(i[0].x, i[0].y);
  for (let r = 1; r < i.length; r += 1)
    e.lineTo(i[r].x, i[r].y);
  e.strokeStyle = o, e.lineWidth = a, e.lineCap = w, e.lineJoin = h, u && (e.setLineDash(u), e.lineDashoffset = y), s && (e.shadowColor = s, e.shadowOffsetX = f, e.shadowOffsetY = g), l && (e.shadowBlur = l), e.stroke(), e.restore();
}
function I(e, i, t = {}) {
  if (!i.length) return;
  e.save();
  const {
    strokeColor: o = "black",
    lineWidth: a = 1,
    lineCap: w = "round",
    lineJoin: h = "round",
    lineDash: u = null,
    lineDashoffset: y = 0,
    fillColor: s = null,
    gradient: l = null,
    shadowColor: f = null,
    shadowBlur: g = 0,
    shadowOffsetX: r = 0,
    shadowOffsetY: N = 0
  } = t;
  e.beginPath(), e.moveTo(i[0].x, i[0].y);
  for (let n = 1; n < i.length; n += 1)
    e.lineTo(i[n].x, i[n].y);
  if (e.closePath(), e.strokeStyle = o, e.lineWidth = a, e.lineCap = w, e.lineJoin = h, u && (e.setLineDash(u), e.lineDashoffset = y), f && (e.shadowColor = f, e.shadowBlur = g, e.shadowOffsetX = r, e.shadowOffsetY = N), l) {
    let n;
    l.type === "linear" ? n = e.createLinearGradient(
      d(l.start.x, Number.MIN_VALUE),
      d(l.start.y, Number.MIN_VALUE),
      d(l.end.x, Number.MIN_VALUE * 2),
      d(l.end.y, Number.MIN_VALUE * 2)
    ) : l.type === "radial" && (n = e.createRadialGradient(
      d(l.start.x, Number.MIN_VALUE),
      d(l.start.y, Number.MIN_VALUE),
      l.start.r || 0,
      d(l.end.x, Number.MIN_VALUE * 2),
      d(l.end.y, Number.MIN_VALUE * 2),
      l.end.r || 0
    )), n && l.stops && (l.stops.forEach((b) => {
      n.addColorStop(b.offset, b.color);
    }), e.fillStyle = n);
  } else s && (e.fillStyle = s);
  e.fillStyle && e.fill(), o && e.stroke(), e.restore();
}
function O(e, i, t = {}) {
  if (!i.length) return;
  e.save();
  const {
    strokeColor: o = "black",
    lineWidth: a = 1,
    lineCap: w = "round",
    lineJoin: h = "round",
    lineDash: u = null,
    lineDashoffset: y = 0,
    fillColor: s = null,
    gradient: l = null,
    shadowColor: f = null,
    shadowBlur: g = 0,
    shadowOffsetX: r = 0,
    shadowOffsetY: N = 0
  } = t;
  e.beginPath(), e.moveTo(i[0].x, i[0].y);
  for (let n = 1; n < i.length; n += 1)
    e.lineTo(i[n].x, i[n].y);
  if (e.closePath(), e.strokeStyle = o, e.lineWidth = a, e.lineCap = w, e.lineJoin = h, u && (e.setLineDash(u), e.lineDashoffset = y), f && (e.shadowColor = f, e.shadowBlur = g, e.shadowOffsetX = r, e.shadowOffsetY = N), l) {
    let n;
    l.type === "linear" ? n = e.createLinearGradient(
      d(l.start.x, Number.MIN_VALUE),
      d(l.start.y, Number.MIN_VALUE),
      d(l.end.x, Number.MIN_VALUE * 2),
      d(l.end.y, Number.MIN_VALUE * 2)
    ) : l.type === "radial" && (n = e.createRadialGradient(
      d(l.start.x, Number.MIN_VALUE),
      d(l.start.y, Number.MIN_VALUE),
      l.start.r || 0,
      d(l.end.x, Number.MIN_VALUE * 2),
      d(l.end.y, Number.MIN_VALUE * 2),
      l.end.r || 0
    )), n && l.stops && (l.stops.forEach((b) => {
      n.addColorStop(b.offset, b.color);
    }), e.fillStyle = n);
  } else s && (e.fillStyle = s);
  e.fillStyle && e.fill(), o && e.stroke(), e.restore();
}
function A(e, i, t, o, a = {}) {
  e.save();
  const {
    font: w = "16px sans-serif",
    color: h = "black",
    align: u = "start",
    baseline: y = "alphabetic",
    maxWidth: s = void 0,
    rotation: l = 0,
    shadowColor: f = null,
    shadowBlur: g = 0,
    shadowOffsetX: r = 0,
    shadowOffsetY: N = 0,
    strokeColor: n = null,
    lineWidth: b = 1,
    globalAlpha: p = 1
  } = a;
  e.font = w, e.fillStyle = h, e.textAlign = u, e.textBaseline = y, e.globalAlpha = p, f && (e.shadowColor = f, e.shadowBlur = g, e.shadowOffsetX = r, e.shadowOffsetY = N), n && (e.strokeStyle = n, e.lineWidth = b), l !== 0 && (e.translate(t, o), e.rotate(Math.PI / 180 * l), e.translate(-t, -o)), e.fillText(i, t, o, s), n && e.strokeText(i, t, o, s), e.restore();
}
function E(e, i = 20) {
  let t;
  return function(...o) {
    const a = this;
    t || (e.apply(a, o), t = !0, setTimeout(() => t = !1, i));
  };
}
function S(e, i, t = !1) {
  let o;
  return function(...a) {
    const w = this, h = function() {
      o = null, t || e.apply(w, a);
    }, u = t && !o;
    clearTimeout(o), o = setTimeout(h, i), u && e.apply(w, a);
  };
}
function k(e) {
  const i = document.createElement("canvas");
  return i.width = e.width || 1, i.height = e.height || 1, e.width || (e.width = 1), e.height || (e.height = 1), i.getContext("2d").drawImage(e, 0, 0), i;
}
function d(e, i) {
  return [null, void 0, NaN, 1 / 0, -1 / 0].includes(e) ? i : e;
}
function M({
  chart: e,
  title: i = null,
  slicer: t = null,
  legend: o = null,
  source: a = null,
  noTitle: w = null,
  padding: h = null
}) {
  let u = 0, y = 0, s = 0, l = 0, f = 0, g = 0, r = 0, N = 0, n = 0;
  if (e) {
    const b = e.parentNode, { height: p, width: C } = b.getBoundingClientRect();
    i ? s = i.getBoundingClientRect().height : s = 0, t ? l = t.getBoundingClientRect().height : l = 0, o ? f = o.getBoundingClientRect().height : f = 0, a ? g = a.getBoundingClientRect().height : g = 0, w ? r = w.getBoundingClientRect().height : r = 0, h ? (N = h.top + h.bottom, n = h.right + h.left) : (N = 0, n = 0), u = p - s - l - f - g - r - N, y = C - n;
  }
  return {
    width: y,
    height: u,
    heightTitle: s,
    heightNoTitle: r,
    heightSource: g,
    heightNoTitle: r,
    heightLegend: f
  };
}
export {
  m as a,
  A as b,
  k as c,
  S as d,
  L as l,
  I as p,
  O as r,
  E as t,
  M as u
};
