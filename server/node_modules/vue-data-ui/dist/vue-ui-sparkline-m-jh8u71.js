import { ref as $, onMounted as Ze, onBeforeUnmount as Be, computed as y, watch as W, nextTick as K, createElementBlock as k, createCommentVNode as S, openBlock as p, Fragment as be, renderList as $e, createElementVNode as M, defineAsyncComponent as ut, toRefs as Bt, shallowRef as st, watchEffect as Dt, normalizeStyle as ae, renderSlot as ge, createBlock as Te, normalizeProps as it, guardReactiveProps as ct, toDisplayString as Ie, unref as g, createVNode as zt, withCtx as Ot, createTextVNode as qt } from "vue";
import { c as Gt, t as dt, aC as Ge, o as vt, g as ht, l as Vt, h as Ee, n as Wt, aq as jt, A as Ve, C as ft, m as Yt, X as Xt, s as Fe, a1 as Ut, Q as pt, a as We, d as je, aD as Kt } from "./lib-CM2Ky_IJ.js";
import { t as Ht, u as Zt } from "./useResponsive-DfdjqQps.js";
import { u as Jt, a as Ye } from "./useNestedProp-BAbkPGYQ.js";
import { u as Qt, B as ea } from "./BaseScanner-BMpwQAfz.js";
import { u as ta } from "./useThemeCheck-D1ZYXUwG.js";
import { u as aa } from "./useTimeLabels-C-A2uZKi.js";
import { u as la } from "./useChartAccessibility-9icAAmYg.js";
import { _ as na } from "./_plugin-vue_export-helper-CHgC5LLL.js";
function ra() {
  const e = $(!1);
  return Ze(() => {
    const a = window.matchMedia("(prefers-reduced-motion: reduce)"), l = () => {
      e.value = a.matches;
    };
    l(), a.addEventListener("change", l), Be(() => {
      a.removeEventListener("change", l);
    });
  }), e;
}
const Ct = { style: { line: { color: "#2A2929" }, area: { color: "#65698E" }, bar: { color: "#2A2929" } } }, wt = { style: { backgroundColor: "#1A1A1A", zeroLine: { color: "#5A5A5A" }, line: { color: "#65698E" }, area: { color: "#8D99AE" }, bar: { color: "#65698E" }, plot: { stroke: "#1A1A1A" }, verticalIndicator: { color: "#8A8A8A" }, dataLabel: { color: "#CCCCCC" }, title: { color: "#CCCCCC" }, tooltip: { backgroundColor: "#1A1A1A", backgroundOpacity: 70, color: "#CCCCCC", borderColor: "#3A3A3A" } } }, At = { style: { backgroundColor: "#1A1A1A", zeroLine: { color: "#5A5A5A" }, plot: { stroke: "#1A1A1A" }, verticalIndicator: { color: "#8A8A8A" }, dataLabel: { color: "#CCCCCC" }, title: { color: "#CCCCCC" }, tooltip: { color: "#CCCCCC", backgroundColor: "#1A1A1A", borderColor: "#5A5A5A", backgroundOpacity: 70 } } }, xt = { style: { backgroundColor: "#FFF8E1", line: { color: "#D32F2F" }, bar: { color: "#D32F2F", borderRadius: 0 }, zeroLine: { color: "#5D4037" }, plot: { stroke: "#FFF8E1" }, verticalIndicator: { color: "#FF9800" }, dataLabel: { color: "#424242" }, title: { color: "#424242" }, area: { color: "#E64A19" }, tooltip: { backgroundColor: "#FFECB3", backgroundOpacity: 30, color: "#424242", borderColor: "#FF8A65" } } }, Lt = { style: { backgroundColor: "#1E1E1E", line: { color: "#D32F2F" }, bar: { color: "#D32F2F", borderRadius: 0 }, zeroLine: { color: "#5D4037" }, plot: { stroke: "#1E1E1E" }, verticalIndicator: { color: "#B71C1C" }, dataLabel: { color: "#BDBDBD" }, title: { color: "#BDBDBD" }, area: { color: "#E64A19" }, tooltip: { backgroundColor: "#1E1E1E", backgroundOpacity: 30, color: "#FFF8E1", borderColor: "#FF8A65" } } }, Mt = { style: { backgroundColor: "#1A1A1A", line: { color: "#66CC66" }, bar: { color: "#66CC66", borderRadius: 0 }, zeroLine: { color: "#5F6A5F" }, plot: { stroke: "#1A1A1A" }, verticalIndicator: { color: "#66CC66" }, dataLabel: { color: "#AACCAA" }, title: { color: "#66CC66" }, area: { color: "#66CC66" }, tooltip: { backgroundColor: "#2A2F2A", color: "#AACCAA", borderColor: "#66CC66" } } }, $t = { style: { backgroundColor: "#fbfafa", line: { color: "#B9B99D", smooth: !0 }, bar: { color: "#B9B99D", borderRadius: 3 }, zeroLine: { strokeWidth: 0 }, plot: { stroke: "#fbfafa" }, verticalIndicator: { color: "#B9B99D" }, dataLabel: { color: "#A0AC94" }, title: { color: "#8A9892" }, area: { color: "#B9B99D" }, tooltip: { backgroundColor: "#fbfafa", color: "#8A9892" } } }, St = { style: { backgroundColor: "#f6f6fb", line: { color: "#4A6A75" }, bar: { color: "#4A6A75", borderRadius: 0 }, zeroLine: { color: "#9FA9BE" }, plot: { stroke: "#f6f6fb" }, verticalIndicator: { color: "#4A6A75" }, dataLabel: { color: "#61747E" }, title: { color: "#50606C" }, area: { color: "#4A6A75" }, tooltip: { backgroundColor: "#f6f6fb", color: "#50606C" } } }, _t = {
  default: {},
  minimal: Ct,
  minimalDark: wt,
  dark: At,
  celebration: xt,
  celebrationNight: Lt,
  hack: Mt,
  zen: $t,
  concrete: St
}, bl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  celebration: xt,
  celebrationNight: Lt,
  concrete: St,
  dark: At,
  default: _t,
  hack: Mt,
  minimal: Ct,
  minimalDark: wt,
  zen: $t
}, Symbol.toStringTag, { value: "Module" })), oa = {
  key: 0,
  style: { "pointer-events": "none" }
}, ua = ["r", "fill", "filter"], sa = ["begin", "dur", "repeatCount", "fill", "calcMode", "keySplines", "keyTimes", "keyPoints"], ia = ["href"], ca = ["dur", "repeatCount", "fill", "values"], da = ["r", "fill"], va = ["begin", "dur", "repeatCount", "calcMode", "keySplines", "keyTimes", "keyPoints"], ha = ["href"], fa = ["dur", "repeatCount"], pa = {
  __name: "SparklinePulse",
  props: {
    uid: { type: String, required: !0 },
    svgRef: { type: Object, default: null },
    pulsePathId: { type: String, required: !0 },
    pulsePathLength: { type: Number, required: !0 },
    pulseDur: { type: String, required: !0 },
    pulseBegin: { type: String, required: !0 },
    pulseRepeatCount: { type: String, required: !0 },
    pulseFillMode: { type: String, default: void 0 },
    pulseKeyPoints: { type: String, required: !0 },
    pulseMotion: { type: Object, required: !0 },
    pulse: { type: Object, required: !0 },
    pulseTrail: { type: Object, required: !0 },
    pulseTrailLength: { type: Number, required: !0 },
    prefersReducedMotion: { type: Boolean, required: !0 },
    loading: { type: Boolean, required: !0 },
    isBar: { type: Boolean, required: !0 }
  },
  setup(e) {
    const a = e, l = y(() => Math.min(a.pulseTrailLength, 45)), u = y(() => !!a.pulse?.show && !a.isBar && !a.prefersReducedMotion && !a.loading && Number(a.pulsePathLength) > 0);
    function r() {
      const i = a.svgRef?.value;
      i && (typeof i.pauseAnimations == "function" && i.pauseAnimations(), typeof i.setCurrentTime == "function" && i.setCurrentTime(0), typeof i.unpauseAnimations == "function" && i.unpauseAnimations());
    }
    function c(i, w) {
      if (typeof i != "string") return i;
      const v = i.trim().match(/^([\d.]+)\s*(ms|s)$/);
      if (!v) return i;
      const m = Number(v[1]), _ = v[2];
      return Number.isNaN(m) ? i : `${m + w}${_}`;
    }
    function d(i) {
      return (l.value - i) / l.value * a.pulse.radius;
    }
    function f(i) {
      const w = a.pulse.trail.opacity, v = (l.value - i) / l.value, m = i === 0 ? 1 : v * w;
      return `0;${m};${m};0`;
    }
    return W(
      () => a.loading,
      async (i) => {
        if (i) {
          r();
          return;
        }
        await K(), r();
      }
    ), W(
      () => a.pulsePathId,
      async () => {
        await K(), r();
      }
    ), Be(() => {
      r();
    }), (i, w) => u.value ? (p(), k("g", oa, [
      (p(!0), k(be, null, $e(l.value, (v, m) => (p(), k(be, null, [
        m % 3 === 0 ? (p(), k("circle", {
          key: `sparkline_dot_${m}_${e.pulsePathId}`,
          r: d(m),
          fill: e.pulse.color,
          filter: `url(#sparkline_pulse_glow_${e.uid})`,
          opacity: "0"
        }, [
          M("animateMotion", {
            begin: c(e.pulseBegin, m * 10),
            dur: e.pulseDur,
            repeatCount: e.pulseRepeatCount,
            fill: e.pulseFillMode,
            calcMode: e.pulseMotion.calcMode,
            keySplines: e.pulseMotion.keySplines || void 0,
            keyTimes: e.pulseMotion.keyTimes || void 0,
            keyPoints: e.pulseKeyPoints,
            rotate: "auto"
          }, [
            M("mpath", {
              href: `#${e.pulsePathId}`
            }, null, 8, ia)
          ], 8, sa),
          M("animate", {
            attributeName: "opacity",
            dur: e.pulseDur,
            repeatCount: e.pulseRepeatCount,
            fill: e.pulseFillMode,
            values: f(m),
            keyTimes: "0;0.1;0.9;1"
          }, null, 8, ca)
        ], 8, ua)) : S("", !0)
      ], 64))), 256)),
      (p(), k("circle", {
        key: `sparkline_halo_${e.pulsePathId}`,
        r: Math.max(e.pulse.radius * 1.3),
        fill: e.pulse.color,
        opacity: "0"
      }, [
        M("animateMotion", {
          begin: e.pulseBegin,
          dur: e.pulseDur,
          repeatCount: e.pulseRepeatCount,
          calcMode: e.pulseMotion.calcMode,
          keySplines: e.pulseMotion.keySplines || void 0,
          keyTimes: e.pulseMotion.keyTimes || void 0,
          keyPoints: e.pulseKeyPoints,
          rotate: "auto"
        }, [
          M("mpath", {
            href: `#${e.pulsePathId}`
          }, null, 8, ha)
        ], 8, va),
        M("animate", {
          attributeName: "opacity",
          values: "0;0.35;0.35;0",
          keyTimes: "0;0.15;0.85;1",
          dur: e.pulseDur,
          repeatCount: e.pulseRepeatCount
        }, null, 8, fa)
      ], 8, da))
    ])) : S("", !0);
  }
}, Re = {
  canvas: null,
  ctx: null
};
function ga() {
  if (typeof document > "u")
    throw new Error("color-utils: document is not available (browser-only).");
  if (!Re.canvas) {
    const e = document.createElement("canvas");
    e.width = 1, e.height = 1;
    const a = e.getContext("2d", { willReadFrequently: !0 });
    if (!a)
      throw new Error("color-utils: unable to get 2D canvas context.");
    Re.canvas = e, Re.ctx = a;
  }
  return Re.ctx;
}
function ya(e) {
  return e < 0 ? 0 : e > 255 ? 255 : Math.round(e);
}
function Qe(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function ma(e, a = null) {
  if (typeof e != "string" || e.trim().length === 0)
    throw new Error("colorToRgba: inputColor must be a non-empty string.");
  const l = e.trim();
  if (l.toLowerCase() === "transparent")
    return { red: 0, green: 0, blue: 0, alpha: 0 };
  const u = ba(l, a), r = ga();
  r.clearRect(0, 0, 1, 1), r.fillStyle = "#000";
  const c = r.fillStyle;
  if (r.fillStyle = u, r.fillStyle === c && !ka(u))
    throw new Error(`colorToRgba: unsupported or invalid color "${e}".`);
  r.fillRect(0, 0, 1, 1);
  const f = r.getImageData(0, 0, 1, 1).data;
  return {
    red: f[0],
    green: f[1],
    blue: f[2],
    alpha: f[3] / 255
  };
}
function gt(e, a = null) {
  if (!Array.isArray(e) || e.length === 0)
    throw new Error("colorsToRgba: colors must be a non-empty array.");
  const l = new Array(e.length);
  for (let u = 0; u < e.length; u += 1)
    l[u] = ma(e[u], a);
  return l;
}
function ba(e, a = null) {
  return e !== "currentColor" || typeof window > "u" || !a ? e : window.getComputedStyle(a).color || e;
}
function ka(e) {
  const a = e.trim().toLowerCase();
  return a === "black" || a === "#000" || a === "#000000" || a === "rgb(0, 0, 0)" || a === "rgba(0, 0, 0, 1)" || a === "rgba(0, 0, 0, 0)";
}
function ye(e) {
  const a = Qe(e / 255);
  return a <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
}
function Xe(e) {
  const a = Qe(e);
  let l;
  return a <= 31308e-7 ? l = a * 12.92 : l = 1.055 * Math.pow(a, 1 / 2.4) - 0.055, ya(l * 255);
}
function yt(e, a, l, u) {
  const r = Qe(l);
  if (u === "linearRGB") {
    const c = ye(e.red), d = ye(e.green), f = ye(e.blue), i = ye(a.red), w = ye(a.green), v = ye(a.blue), m = c + (i - c) * r, _ = d + (w - d) * r, N = f + (v - f) * r;
    return {
      red: Xe(m),
      green: Xe(_),
      blue: Xe(N),
      alpha: e.alpha + (a.alpha - e.alpha) * r
    };
  }
  return {
    red: e.red + (a.red - e.red) * r,
    green: e.green + (a.green - e.green) * r,
    blue: e.blue + (a.blue - e.blue) * r,
    alpha: e.alpha + (a.alpha - e.alpha) * r
  };
}
function q(e, a, l) {
  let u = e;
  return u < a && (u = a), u > l && (u = l), u;
}
function H(e, a) {
  const l = Math.pow(10, a);
  return Math.round(e * l) / l;
}
function le(e) {
  return Number.isFinite(e) ? e.toString() : "0";
}
function Ue(e) {
  const l = q(e, 0, 255).toString(16);
  return l.length === 1 ? "0" + l : l;
}
function Ca(e) {
  if (typeof e != "string") return;
  const a = Number.parseFloat(e);
  return Number.isFinite(a) ? a : void 0;
}
function wa(e, a, l, u = !0) {
  const r = l - a;
  if (r === 0) return 0;
  const c = (e - a) / r;
  return u ? q(c, 0, 1) : c;
}
const mt = "http://www.w3.org/2000/svg";
function Aa(e) {
  if (typeof document > "u")
    throw new Error("SvgPathGradientAsync: document is not available (browser-only implementation).");
  const a = document.createElementNS(mt, "svg");
  a.setAttribute("width", "0"), a.setAttribute("height", "0"), a.setAttribute("viewBox", "0 0 0 0"), a.style.position = "absolute", a.style.left = "-10000px", a.style.top = "-10000px", a.style.visibility = "hidden", a.style.pointerEvents = "none";
  const l = document.createElementNS(mt, "path");
  return e === "M " && (e = "M 0,0"), l.setAttribute("d", e), a.appendChild(l), document.body.appendChild(a), { svgElement: a, pathElement: l };
}
function Ke(e) {
  if (e)
    try {
      e.svgElement?.remove?.();
    } catch {
    }
}
function xa(e, a, l) {
  if (typeof l == "number" && l > 0)
    return l;
  let u = a * 0.75;
  u < 0.5 && (u = 0.5), u > 8 && (u = 8);
  const r = e / 2;
  return u > r && r > 0 && (u = r), u <= 0 && (u = 1), u;
}
function La(e, a, l) {
  if (typeof a == "number" && a >= 1)
    return Math.floor(a);
  const u = typeof l == "number" && l > 0 ? l : 2, r = Math.ceil(e / u);
  return r < 1 ? 1 : r;
}
function Ma(e, a, l, u, r, c) {
  const d = l - a;
  let f = Math.ceil(d / u) + 1;
  f < 2 && (f = 2), f > c && (f = c);
  const i = f > 1 ? d / (f - 1) : 0, w = e.getPointAtLength(a);
  let v = `M ${le(H(w.x, r))} ${le(
    H(w.y, r)
  )}`;
  for (let m = 1; m < f; m += 1) {
    const _ = a + m * i, N = e.getPointAtLength(_);
    v += ` L ${le(H(N.x, r))} ${le(
      H(N.y, r)
    )}`;
  }
  return v;
}
function $a(e, a, l, u, r, c) {
  const d = l - a;
  let f = Math.ceil(d / u) + 1;
  f < 2 && (f = 2), f > c && (f = c);
  const i = f > 1 ? d / (f - 1) : 0, w = e.getPointAtLength(a);
  let v = w.x, m = w.x, _ = w.y, N = w.y, t = `M ${le(H(w.x, r))} ${le(
    H(w.y, r)
  )}`;
  for (let z = 1; z < f; z += 1) {
    const ne = a + z * i, C = e.getPointAtLength(ne);
    C.x < v && (v = C.x), C.x > m && (m = C.x), C.y < _ && (_ = C.y), C.y > N && (N = C.y), t += ` L ${le(H(C.x, r))} ${le(
      H(C.y, r)
    )}`;
  }
  return {
    pathData: t,
    bounds: { minX: v, maxX: m, minY: _, maxY: N }
  };
}
function Sa(e) {
  if (e.length === 1) return [{ position: 0, rgba: e[0] }];
  const a = new Array(e.length), l = e.length - 1;
  for (let u = 0; u < e.length; u += 1)
    a[u] = { position: u / l, rgba: e[u] };
  return a;
}
function _a(e, a, l, u) {
  const r = q(a, 0, 1);
  let c = u;
  for (c < 0 && (c = 0), c > e.length - 2 && (c = e.length - 2); c > 0 && r < e[c].position; ) c -= 1;
  for (; c < e.length - 2 && r > e[c + 1].position; ) c += 1;
  const d = e[c], f = e[c + 1], i = f.position - d.position, w = i > 0 ? (r - d.position) / i : 0, v = Pa(d.rgba, f.rgba, w, l);
  return Je(v);
}
function Pa(e, a, l, u) {
  const r = q(l, 0, 1);
  if (u === "linearRGB") {
    const c = me(e.red), d = me(e.green), f = me(e.blue), i = me(a.red), w = me(a.green), v = me(a.blue), m = c + (i - c) * r, _ = d + (w - d) * r, N = f + (v - f) * r;
    return {
      red: He(m),
      green: He(_),
      blue: He(N),
      alpha: e.alpha + (a.alpha - e.alpha) * r
    };
  }
  return {
    red: e.red + (a.red - e.red) * r,
    green: e.green + (a.green - e.green) * r,
    blue: e.blue + (a.blue - e.blue) * r,
    alpha: e.alpha + (a.alpha - e.alpha) * r
  };
}
function me(e) {
  const a = q(e / 255, 0, 1);
  return a <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
}
function He(e) {
  const a = q(e, 0, 1);
  let l;
  a <= 31308e-7 ? l = a * 12.92 : l = 1.055 * Math.pow(a, 1 / 2.4) - 0.055;
  const u = Math.round(l * 255);
  return q(u, 0, 255);
}
function Je(e) {
  const a = q(e.alpha, 0, 1), l = q(Math.round(e.red), 0, 255), u = q(Math.round(e.green), 0, 255), r = q(Math.round(e.blue), 0, 255);
  if (a >= 1)
    return `#${Ue(l)}${Ue(u)}${Ue(r)}`;
  const c = H(a, 4).toString();
  return `rgba(${l}, ${u}, ${r}, ${c})`;
}
function Na(e) {
  const a = e.fill ?? "none";
  let l = `fill="${Z(a)}"`;
  const u = Object.keys(e);
  for (let r = 0; r < u.length; r += 1) {
    const c = u[r];
    if (c === "stroke" || c === "d") continue;
    const d = e[c];
    l += ` ${c}="${Z(d)}"`;
  }
  return l;
}
function bt(e, a, l) {
  return `<path d="${Z(e)}" stroke="${Z(a)}" ${l} />`;
}
function Ta(e) {
  const a = [], l = e.segmentAttributeMap.fill ?? "none";
  a.push(`fill="${Z(l)}"`), a.push(`stroke="${Z(e.stroke)}"`);
  for (const u of Object.keys(e.segmentAttributeMap)) {
    if (u === "stroke" || u === "d") continue;
    const r = e.segmentAttributeMap[u];
    a.push(`${u}="${Z(r)}"`);
  }
  return `<path d="${Z(e.pathData)}" ${a.join(" ")} />`;
}
function kt(e, a) {
  const l = [];
  for (const r of Object.keys(a))
    l.push(`${r}="${Z(a[r])}"`);
  return `<g data-svg-path-gradient="true"${l.length ? " " + l.join(" ") : ""}>${e.join("")}</g>`;
}
function Z(e) {
  return String(e).replaceAll("&", "&amp;").replaceAll('"', "&quot;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function Ia(e, a = null, l = {}) {
  return new Promise((u, r) => {
    let c = null;
    try {
      if (!e || typeof e != "string")
        throw new Error("SvgPathGradientAsync: pathData must be a non-empty string.");
      const d = l.temperatureMode ?? null;
      if (d === null && (!Array.isArray(a) || a.length === 0))
        throw new Error("SvgPathGradientAsync: colors must be a non-empty array when temperatureMode is not enabled.");
      if ((l.returnMode ?? "string") !== "string")
        throw new Error('SvgPathGradientAsync: only returnMode="string" is supported for the async version.');
      const i = typeof l.decimalPlaces == "number" ? l.decimalPlaces : 3, w = typeof l.flattenTolerance == "number" && l.flattenTolerance > 0 ? l.flattenTolerance : 0.25, v = l.attrs ? { ...l.attrs } : {}, m = l.groupAttrs ? { ...l.groupAttrs } : {}, _ = Ca(v["stroke-width"]), N = typeof l.strokeWidth == "number" && l.strokeWidth > 0 ? l.strokeWidth : typeof _ == "number" && _ > 0 ? _ : 1;
      c = Aa(e);
      const t = c.pathElement, z = t.getTotalLength(), ne = d === null ? gt(a, l.colorReferenceElement) : [];
      if (d === null && (!(z > 0) || ne.length === 1)) {
        const P = Je(ne[0]), I = kt(
          [
            Ta({
              pathData: e,
              stroke: P,
              segmentAttributeMap: v
            })
          ],
          m
        );
        Ke(c), u(I);
        return;
      }
      const C = l.colorSpace ?? "linearRGB";
      if (d !== null) {
        const P = l.temperatureColors;
        if (!Array.isArray(P) || P.length !== 2)
          throw new Error("SvgPathGradientAsync: temperatureColors must be a tuple of exactly 2 colors when temperatureMode is enabled.");
      }
      const J = d !== null ? gt(l.temperatureColors, l.colorReferenceElement) : null, re = d === null ? (() => {
        const P = Sa(ne), I = new Array(P.length);
        for (let X = 0; X < P.length; X += 1)
          I[X] = { position: P[X].position, rgba: P[X].rgba };
        return I;
      })() : [], ce = xa(z, N, l.maxSegmentLength), Q = La(z, l.segments, ce), T = z / Q;
      let de = typeof l.overlap == "number" && l.overlap >= 0 ? l.overlap : N * 0.5;
      const oe = T * 0.45;
      de > oe && (de = oe);
      const Se = typeof l.samplePointLimitPerSegment == "number" && l.samplePointLimitPerSegment > 10 ? l.samplePointLimitPerSegment : 250, _e = Na(v), ve = [], Pe = d !== null ? [] : null, ue = d !== null ? [] : null;
      let ee = 0;
      const ke = d === null ? re.length - 2 : 0;
      let Y = 0;
      const Ce = () => {
        const P = performance.now(), I = typeof l.frameBudgetMs == "number" ? l.frameBudgetMs : 8;
        for (; Y < Q && performance.now() - P < I; ) {
          const D = Y * T, O = (Y + 1) * T;
          let E = D, F = O;
          if (Y !== 0 && (E = D - de), Y !== Q - 1 && (F = O + de), E = q(E, 0, z), F = q(F, 0, z), F > E)
            if (d !== null) {
              const R = $a(
                t,
                E,
                F,
                w,
                i,
                Se
              );
              Pe.push(R.pathData), ue.push(R.bounds);
            } else {
              const B = (E + F) * 0.5 / z;
              for (; ee < ke && B > re[ee + 1].position; )
                ee += 1;
              const j = _a(
                re,
                B,
                C,
                ee
              ), G = Ma(
                t,
                E,
                F,
                w,
                i,
                Se
              );
              ve.push(
                bt(G, j, _e)
              );
            }
          Y += 1;
        }
        if (Y < Q) {
          requestAnimationFrame(Ce);
          return;
        }
        if (d !== null) {
          let D = Number.POSITIVE_INFINITY, O = Number.NEGATIVE_INFINITY;
          for (let R = 0; R < ue.length; R += 1) {
            const B = ue[R], j = d === "vertical" ? B.minY : B.minX, G = d === "vertical" ? B.maxY : B.maxX;
            j < D && (D = j), G > O && (O = G);
          }
          const E = J[0], F = J[1];
          ve.length = 0;
          for (let R = 0; R < ue.length; R += 1) {
            const B = ue[R], j = d === "vertical" ? B.minY : B.minX, G = d === "vertical" ? B.maxY : B.maxX, we = (j + G) * 0.5, Ae = wa(we, D, O, !0), se = d === "vertical" ? yt(E, F, Ae, C) : yt(F, E, Ae, C), xe = Je(se), Ne = Pe[R];
            ve.push(
              bt(Ne, xe, _e)
            );
          }
        }
        const X = kt(ve, m);
        Ke(c), u(X);
      };
      requestAnimationFrame(Ce);
    } catch (d) {
      Ke(c), r(d);
    }
  });
}
const Ea = ["innerHTML"], Fa = {
  __name: "SparklineGradientPath",
  props: {
    svgPathData: { type: String, required: !0 },
    enabled: { type: Boolean, required: !0 },
    strokeWidth: { type: Number, required: !0 },
    highColor: { type: String, required: !0 },
    lowColor: { type: String, required: !0 },
    segments: { type: Number, required: !0 }
  },
  setup(e) {
    const a = e, l = $("");
    let u = 0;
    return W(
      () => [
        a.enabled,
        a.svgPathData,
        a.strokeWidth,
        a.highColor,
        a.lowColor,
        a.segments
      ],
      async ([r]) => {
        const c = ++u;
        if (!r) {
          l.value = "";
          return;
        }
        const d = await Ia(a.svgPathData, null, {
          segments: a.segments,
          temperatureMode: "vertical",
          temperatureColors: [a.highColor, a.lowColor],
          attrs: {
            "stroke-width": a.strokeWidth,
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
          },
          groupAttrs: { class: "vue-ui-sparkline-gradient" }
        });
        c === u && (l.value = d);
      },
      { immediate: !0 }
    ), (r, c) => (p(), k("g", { innerHTML: l.value }, null, 8, Ea));
  }
}, Ra = ["id"], Ba = ["xmlns", "viewBox"], Da = ["width", "height"], za = ["id"], Oa = ["stop-color"], qa = ["stop-color"], Ga = ["id"], Va = ["stop-color"], Wa = ["stop-color"], ja = ["id"], Ya = ["stop-color"], Xa = ["stop-color"], Ua = ["id"], Ka = ["id"], Ha = ["stop-color", "offset"], Za = { key: 1 }, Ja = ["d", "fill"], Qa = ["d", "fill"], el = ["id", "d", "stroke", "stroke-width"], tl = ["id", "d", "stroke", "stroke-width"], al = ["x", "y", "width", "height", "fill", "rx"], ll = ["x1", "x2", "y1", "y2", "stroke", "stroke-width", "stroke-dasharray"], nl = ["x1", "x2", "y1", "y2", "stroke", "stroke-dasharray", "stroke-width"], rl = ["cx", "cy", "r", "fill", "stroke", "stroke-width"], ol = ["x", "y", "font-size", "font-weight", "fill"], ul = ["x", "y", "height", "width", "onMouseenter", "onMouseleave", "onClick"], sl = {
  __name: "vue-ui-sparkline",
  props: {
    config: {
      type: Object,
      default() {
        return {};
      }
    },
    dataset: {
      type: Array,
      default() {
        return [];
      }
    },
    showInfo: {
      type: Boolean,
      default: !0
    },
    selectedIndex: {
      type: Number,
      default: void 0
    },
    heightRatio: {
      type: Number,
      default: 1
    },
    forcedPadding: {
      type: Number,
      default: 30
    }
  },
  emits: ["hoverIndex", "selectDatapoint"],
  setup(e, { emit: a }) {
    const l = ut(() => import("./PackageVersion-Db45mlY0.js")), u = ut(() => import("./SparkTooltip-FXQZa3m1.js")), { vue_ui_sparkline: r } = Jt(), { isThemeValid: c, warnInvalidTheme: d } = ta(), f = ra(), i = e, w = y(() => Array.isArray(i.dataset) && i.dataset.length > 0), v = $(Gt()), m = $(null), _ = $(null), N = $(null), t = $(Q());
    function z(n) {
      return i.config?.skeletonDataset && Array.isArray(i.config.skeletonDataset) ? i.config.skeletonDataset.map((o) => ({ period: "-", value: o })) : Kt(n).map((o) => ({ period: "-", value: o }));
    }
    const ne = y(() => dt({
      defaultConfig: {
        gradientPath: { show: !1 },
        temperatureColors: { show: !1 },
        style: {
          backgroundColor: "#99999930",
          scaleMin: 0,
          scaleMax: null,
          animation: { show: !1 },
          line: { color: "#AAAAAA", pulse: { show: !1 } },
          bar: { color: "#AAAAAA" },
          area: { color: "#CACACA" },
          zeroLine: { color: "#6A6A6A" },
          dataLabel: { show: !1 },
          tooltip: { show: !1 }
        }
      },
      userConfig: t.value.skeletonConfig ?? {}
    })), { loading: C, FINAL_DATASET: J, manualLoading: re } = Qt({
      ...Bt(i),
      FINAL_CONFIG: t,
      prepareConfig: Q,
      callback: () => {
        Promise.resolve().then(async () => {
          await K(), we();
        });
      },
      skeletonDataset: z(12),
      skeletonConfig: dt({
        defaultConfig: t.value,
        userConfig: ne.value
      })
    }), { svgRef: ce } = la({ config: t.value.style.title });
    function Q() {
      const n = Ye({
        userConfig: i.config,
        defaultConfig: r
      });
      let o = {};
      const s = n.theme;
      if (s)
        if (!c.value(n))
          d(n), o = n;
        else {
          const h = Ye({
            userConfig: _t[s] || i.config,
            defaultConfig: n
          });
          o = {
            ...Ye({
              userConfig: i.config,
              defaultConfig: h
            })
          };
        }
      else
        o = n;
      return o;
    }
    const T = y(() => t.value?.style?.line.pulse || {}), de = y(() => `${Math.max(200, Number(T.value.durationMs) || 4e3) / 1e3}s`), oe = $(0), Se = y(() => T.value?.begin || "0ms"), _e = $("0;1"), ve = y(() => T.value?.loop === !1 ? "1" : "indefinite"), Pe = y(() => T.value?.loop === !1 ? "freeze" : void 0), ue = y(() => T.value.trail.show && Ce.value.lengthPx || 1), ee = y(() => !!T.value?.show && !U.value && !f.value && !C.value && (A.value?.length || 0) > 1);
    function ke() {
      if (!ee.value) {
        oe.value = 0;
        return;
      }
      const n = ce.value;
      if (!n) return;
      const o = `#${se.value}`, s = n.querySelector?.(o);
      if (s && typeof s.getTotalLength == "function") {
        const h = s.getTotalLength();
        Number.isFinite(h) && h > 0 && (oe.value = h);
        return;
      }
      requestAnimationFrame(() => {
        const h = n.querySelector?.(o);
        if (h && typeof h.getTotalLength == "function") {
          const V = h.getTotalLength();
          Number.isFinite(V) && V > 0 && (oe.value = V);
        }
      });
    }
    const Y = y(() => {
      const n = T.value?.easing || "ease-in-out", o = {
        ease: [0.25, 0.1, 0.25, 1],
        "ease-in": [0.42, 0, 1, 1],
        "ease-out": [0, 0, 0.58, 1],
        "ease-in-out": [0.42, 0, 0.58, 1]
      };
      return n === "linear" ? {
        calcMode: "linear",
        keySplines: null,
        keyTimes: "0;1"
      } : n === "steps" ? {
        calcMode: "discrete",
        keySplines: null,
        keyTimes: "0;1"
      } : {
        calcMode: "spline",
        keySplines: (n === "cubic-bezier" ? Array.isArray(T.value?.cubicBezier) && T.value.cubicBezier.length === 4 ? T.value.cubicBezier : [0.4, 0, 0.2, 1] : o[n] || o["ease-in-out"]).join(" "),
        keyTimes: "0;1"
      };
    }), Ce = y(() => {
      const n = T.value?.trail || {}, o = t.value.style.line.strokeWidth || 1;
      return {
        show: n.show !== !1,
        lengthPx: n.length,
        width: Math.max(1, Number(n.strokeWidth) || o * 2.2),
        opacity: Math.min(1, Math.max(0, Number(n.opacity) ?? 0.6)),
        fadeIn: 0.5,
        fadeOut: 0.2
      };
    }), P = y(() => Ge({
      data: J.value,
      threshold: t.value.downsample.threshold
    }));
    W(() => i.config, (n) => {
      C.value || (t.value = Q()), tt(), b.value.chartWidth = t.value.style.chartWidth;
    }, { deep: !0 }), W(() => i.dataset, (n) => {
      Array.isArray(n) && n.length > 0 && (re.value = !1), I.value = Ge({
        data: J.value.map((o) => ({
          ...o,
          value: [void 0].includes(o.value) ? null : o.value
        })),
        threshold: t.value.downsample.threshold
      });
    }, { deep: !0 });
    const I = $(X());
    function X() {
      return Ge({
        data: J.value.map((n) => t.value.style.animation.show && J.value.length > 1 ? {
          ...n,
          value: null
        } : {
          ...n,
          value: [void 0].includes(n.value) ? null : n.value
        }),
        threshold: t.value.downsample.threshold
      });
    }
    const D = st(null), O = st(null), E = $(!1), F = $(0), R = $([]), B = $(""), j = y(() => {
      const o = (P.value || []).map((V) => `${V.period}::${Number.isFinite(V.value) ? V.value : 0}`).join("|"), s = t.value?.style?.animation || {}, h = !!t.value?.gradientPath?.show && !t.value.temperatureColors.show;
      return `${o}#${!!s.show}#${s.animationFrames || 0}#${h}`;
    });
    function G() {
      F.value && (cancelAnimationFrame(F.value), F.value = 0), R.value.forEach((n) => clearTimeout(n)), R.value = [], E.value = !1;
    }
    function we() {
      const n = t.value?.style?.animation || {}, o = P.value || [], s = j.value, h = !!t.value.gradientPath.show && !t.value.temperatureColors.show;
      if (s && s === B.value && (E.value || I.value.length === o.length))
        return;
      if (G(), h || !n.show || C.value || o.length <= 1) {
        I.value = o, B.value = s;
        return;
      }
      E.value = !0, B.value = s, I.value = [];
      const V = Math.max(1, Number(n.animationFrames) || 1), Ft = Math.max(1, Math.floor(V / o.length));
      let qe = 0;
      const ot = () => {
        if (s !== j.value) {
          G();
          return;
        }
        if (qe < o.length) {
          I.value.push(o[qe]);
          const Rt = setTimeout(() => {
            F.value = requestAnimationFrame(ot);
          }, Ft);
          R.value.push(Rt), qe += 1;
        } else
          I.value = o, G();
      };
      F.value = requestAnimationFrame(ot);
    }
    W(j, () => {
      we();
    }), Ze(() => {
      tt(), we();
    }), Be(() => {
      G();
    });
    const Ae = $(0);
    W(
      () => C.value,
      async (n) => {
        n || (await K(), Ae.value += 1);
      }
    ), W(
      () => E.value,
      async (n) => {
        n || C.value || (await K(), Ae.value += 1);
      }
    );
    const se = y(() => `sparkline_line_path_${v.value}`), xe = $(!0);
    async function Ne() {
      xe.value = !1, await K(), xe.value = !0, await K(), ke();
    }
    const et = y(() => !!t.value.debug);
    function tt() {
      if (vt(i.dataset) ? (ht({
        componentName: "VueUiSparkline",
        type: "dataset",
        debug: et.value
      }), re.value = !0) : i.dataset.forEach((n, o) => {
        Vt({
          datasetObject: n,
          requiredAttributes: ["period", "value"]
        }).forEach((s) => {
          ht({
            componentName: "VueUiSparkline",
            type: "datasetSerieAttribute",
            property: s,
            index: o,
            debug: et.value
          });
        });
      }), vt(i.dataset) || (re.value = t.value.loading), t.value.responsive) {
        const n = Ht(() => {
          const { width: o, height: s } = Zt({
            chart: m.value,
            title: t.value.style.title.show && i.showInfo ? _.value : null,
            source: N.value
          });
          requestAnimationFrame(() => {
            b.value.width = o, b.value.height = s, b.value.chartWidth = t.value.style.chartWidth / 500 * o, b.value.padding = i.forcedPadding / 500 * o;
          });
        });
        D.value && (O.value && D.value.unobserve(O.value), D.value.disconnect()), D.value = new ResizeObserver(n), O.value = m.value.parentNode, D.value.observe(O.value);
      }
    }
    Be(() => {
      D.value && (O.value && D.value.unobserve(O.value), D.value.disconnect());
    });
    const b = $({
      height: 80 * i.heightRatio,
      width: 500,
      chartWidth: t.value.style.chartWidth,
      padding: i.forcedPadding
    }), De = a, x = y(() => {
      const { top: n, right: o, bottom: s, left: h } = t.value.style.padding;
      return {
        top: n,
        left: h,
        right: b.value.width - o,
        bottom: b.value.height - s,
        start: i.showInfo && t.value.style.dataLabel.show && t.value.style.dataLabel.position === "left" ? b.value.width - b.value.chartWidth + h : b.value.padding + h,
        width: i.showInfo && t.value.style.dataLabel.show ? b.value.chartWidth - h - o : b.value.width - b.value.padding - h - o,
        height: b.value.height - n - s
      };
    }), ze = y(() => [null, void 0].includes(t.value.style.scaleMin) ? Math.min(...I.value.map((n) => isNaN(n.value) || [void 0, null, "NaN", NaN, 1 / 0, -1 / 0].includes(n.value) ? 0 : n.value || 0)) : t.value.style.scaleMin), Pt = y(() => [null, void 0].includes(t.value.style.scaleMax) ? Math.max(...I.value.map((n) => isNaN(n.value) || [void 0, null, "NaN", NaN, 1 / 0, -1 / 0].includes(n.value) ? 0 : n.value || 0)) : t.value.style.scaleMax), Le = y(() => {
      const n = ze.value >= 0 ? 0 : ze.value;
      return Math.abs(n);
    }), at = y(() => Pt.value + Le.value), he = y(() => x.value.bottom - x.value.height * Oe(Le.value));
    function Oe(n) {
      return isNaN(n / at.value) ? 0 : n / at.value;
    }
    const fe = y(() => P.value.length - 1 || 1), Me = $([]);
    let lt = 0;
    Dt(() => {
      const n = ++lt;
      (async () => {
        const o = await aa({
          values: P.value.map((s) => s.period),
          maxDatapoints: P.value.length,
          formatter: t.value.style.dataLabel.datetimeFormatter,
          start: 0,
          end: P.value.length
        });
        n === lt && (Me.value = o);
      })();
    });
    const A = y(() => I.value.map((n, o) => {
      const s = isNaN(n.value) || [void 0, null, "NaN", NaN, 1 / 0, -1 / 0].includes(n.value) ? 0 : n.value || 0, h = x.value.width / fe.value;
      return {
        absoluteValue: s,
        period: Me.value && Me.value[o] && Me.value[o].text ? Me.value[o].text : n.period,
        plotValue: s + Le.value,
        toMax: Oe(s + Le.value),
        x: x.value.start + o * h,
        y: x.value.bottom - x.value.height * Oe(s + Le.value),
        id: `plot_${v.value}_${o}`,
        color: U.value ? t.value.style.bar.color : t.value.style.area.useGradient ? Ee(t.value.style.line.color, 0.05 * (1 - o / fe.value)) : t.value.style.line.color,
        width: h
      };
    })), Nt = y(() => {
      const n = { x: A.value[0].x || 0, y: (b.value.height || 0) - 6 }, o = { x: A.value[A.value.length - 1].x || 0, y: (b.value.height || 0) - 6 }, s = [];
      return A.value.forEach((h) => {
        s.push(`${h.x || 0},${h.y || 0} `);
      }), [n.x, n.y, ...s, o.x, o.y].toString();
    }), L = $(void 0), pe = $(void 0);
    function Tt(n, o) {
      t.value.events.datapointEnter && t.value.events.datapointEnter({ datapoint: n, seriesIndex: o }), L.value = n, pe.value || (pe.value = n), De("hoverIndex", { index: o });
    }
    function It(n, o) {
      t.value.events.datapointLeave && t.value.events.datapointLeave({ datapoint: n, seriesIndex: o }), pe.value = L.value, L.value = void 0, De("hoverIndex", { index: void 0 });
    }
    const te = y(() => {
      if (w.value) {
        const n = A.value.map((s) => s.absoluteValue), o = n.reduce((s, h) => s + h, 0);
        return {
          latest: A.value[A.value.length - 1] ? A.value[A.value.length - 1].absoluteValue : 0,
          sum: o,
          average: o / A.value.length,
          median: jt(n),
          trend: Wt(A.value.map(({ x: s, y: h, absoluteValue: V }) => ({
            x: s,
            y: h,
            value: V
          }))).trend
        };
      } else
        return {
          latest: null,
          sum: null,
          average: null,
          median: null,
          trend: null
        };
    }), nt = y(() => w.value ? t.value.style.dataLabel.valueType === "latest" ? te.value.latest : t.value.style.dataLabel.valueType === "sum" ? te.value.sum : t.value.style.dataLabel.valueType === "average" ? te.value.average : 0 : 0), U = y(() => t.value.type && t.value.type === "bar");
    function Et(n, o) {
      t.value.events.datapointClick && t.value.events.datapointClick({ datapoint: n, seriesIndex: o }), De("selectDatapoint", { datapoint: n, index: o });
    }
    const rt = y(() => U.value || !t.value.gradientPath.show || t.value.temperatureColors.show ? "" : `M ${(t.value.style.line.smooth ? Ve(A.value) : ft(A.value)) || "0,0"}`), ie = y(() => !t.value.temperatureColors.show || t.value.temperatureColors.colors.length === 0 ? null : t.value.temperatureColors.colors.map((n) => Yt(n)));
    return W(
      () => [
        ee.value,
        se.value,
        A.value.length,
        b.value.width,
        b.value.height,
        t.value?.style?.line?.smooth
      ],
      async () => {
        await K(), ke();
      },
      { immediate: !0 }
    ), Ze(async () => {
      await K(), ke();
    }), W(
      () => C.value,
      async (n) => {
        n || await Ne();
      }
    ), W(
      () => E.value,
      async (n) => {
        n || C.value || await Ne();
      }
    ), (n, o) => (p(), k("div", {
      ref_key: "sparklineChart",
      ref: m,
      class: "vue-data-ui-component vue-ui-sparkline",
      id: v.value,
      style: ae(`width:100%;font-family:${t.value.style.fontFamily};`)
    }, [
      ge(n.$slots, "before", it(ct({
        selected: L.value,
        latest: te.value.latest,
        sum: te.value.sum,
        average: te.value.average,
        median: te.value.median,
        trend: te.value.trend
      })), void 0, !0),
      t.value.style.title.show && e.showInfo ? (p(), k("div", {
        key: 0,
        ref_key: "chartTitle",
        ref: _,
        class: "vue-ui-sparkline-title",
        style: ae(`display:flex;align-items:center;width:100%;color:${t.value.style.title.color};background:${t.value.style.backgroundColor};justify-content:${t.value.style.title.textAlign === "left" ? "flex-start" : t.value.style.title.textAlign === "right" ? "flex-end" : "center"};height:${t.value.style.title.fontSize * 2}px;font-size:${t.value.style.title.fontSize}px;font-weight:${t.value.style.title.bold ? "bold" : "normal"};`)
      }, [
        M("span", {
          style: ae(`padding:${t.value.style.title.textAlign === "left" ? "0 0 0 12px" : t.value.style.title.textAlign === "right" ? "0 12px 0 0" : "0"}`)
        }, Ie(L.value ? L.value.period : t.value.style.title.text), 5)
      ], 4)) : S("", !0),
      (p(), k("svg", {
        ref_key: "svgRef",
        ref: ce,
        xmlns: g(Xt),
        viewBox: `0 0 ${b.value.width} ${b.value.height}`,
        style: ae(`background:${t.value.style.backgroundColor};overflow:visible`),
        onMouseleave: o[0] || (o[0] = (s) => pe.value = void 0)
      }, [
        zt(g(l)),
        n.$slots["chart-background"] ? (p(), k("foreignObject", {
          key: 0,
          x: 0,
          y: 0,
          width: b.value.width <= 0 ? 10 : b.value.width,
          height: b.value.height <= 0 ? 10 : b.value.height,
          style: {
            pointerEvents: "none"
          }
        }, [
          ge(n.$slots, "chart-background", {}, void 0, !0)
        ], 8, Da)) : S("", !0),
        M("defs", null, [
          M("linearGradient", {
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%",
            id: `sparkline_gradient_${v.value}`
          }, [
            M("stop", {
              offset: "0%",
              "stop-color": g(Fe)(g(Ee)(t.value.style.area.color, 0.05), t.value.style.area.opacity)
            }, null, 8, Oa),
            M("stop", {
              offset: "100%",
              "stop-color": g(Fe)(t.value.style.area.color, t.value.style.area.opacity)
            }, null, 8, qa)
          ], 8, za),
          M("linearGradient", {
            x2: "0%",
            y2: "100%",
            id: `sparkline_bar_gradient_pos_${v.value}`
          }, [
            M("stop", {
              offset: "0%",
              "stop-color": t.value.style.bar.color
            }, null, 8, Va),
            M("stop", {
              offset: "100%",
              "stop-color": g(Ee)(t.value.style.bar.color, 0.05)
            }, null, 8, Wa)
          ], 8, Ga),
          M("linearGradient", {
            x2: "0%",
            y2: "100%",
            id: `sparkline_bar_gradient_neg_${v.value}`
          }, [
            M("stop", {
              offset: "0%",
              "stop-color": g(Ee)(t.value.style.bar.color, 0.05)
            }, null, 8, Ya),
            M("stop", {
              offset: "100%",
              "stop-color": t.value.style.bar.color
            }, null, 8, Xa)
          ], 8, ja),
          M("filter", {
            id: `sparkline_pulse_glow_${v.value}`,
            filterUnits: "userSpaceOnUse",
            x: "-50",
            y: "-50",
            width: "100",
            height: "100"
          }, [...o[1] || (o[1] = [
            M("feGaussianBlur", {
              in: "SourceGraphic",
              stdDeviation: "3",
              result: "blur"
            }, null, -1),
            M("feMerge", null, [
              M("feMergeNode", { in: "blur" }),
              M("feMergeNode", { in: "SourceGraphic" })
            ], -1)
          ])], 8, Ua),
          t.value.temperatureColors.show && ie.value ? (p(), k("linearGradient", {
            key: 0,
            id: `temperature_grad_sparkline_${v.value}`,
            gradientTransform: "rotate(90)"
          }, [
            (p(!0), k(be, null, $e(ie.value, (s, h) => (p(), k("stop", {
              key: `temperature_grad_stop_${h}_${v.value}`,
              "stop-color": s,
              offset: g(Ut)(h, ie.value.length)
            }, null, 8, Ha))), 128))
          ], 8, Ka)) : S("", !0)
        ]),
        t.value.style.area.show && !U.value && A.value[0] && A.value.length > 1 ? (p(), k("g", Za, [
          t.value.style.line.smooth ? (p(), k("path", {
            key: 0,
            class: "vue-ui-sparkline-area",
            d: `M ${A.value[0].x},${x.value.bottom} ${g(Ve)(A.value)} L ${A.value.at(-1).x},${x.value.bottom} Z`,
            fill: t.value.style.area.useGradient ? `url(#sparkline_gradient_${v.value})` : g(Fe)(t.value.style.area.color, t.value.style.area.opacity),
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            style: ae({
              transition: g(C) ? void 0 : "all 0.2s"
            })
          }, null, 12, Ja)) : (p(), k("path", {
            key: 1,
            class: "vue-ui-sparkline-area",
            d: `M${Nt.value}Z`,
            fill: t.value.style.area.useGradient ? `url(#sparkline_gradient_${v.value})` : g(Fe)(t.value.style.area.color, t.value.style.area.opacity),
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            style: ae({
              transition: g(C) ? void 0 : "all 0.2s"
            })
          }, null, 12, Qa))
        ])) : S("", !0),
        t.value.style.line.smooth && !U.value ? (p(), k("path", {
          key: 2,
          class: "vue-ui-sparkline-path",
          id: se.value,
          d: `M ${g(Ve)(A.value) || "0,0"}`,
          stroke: ie.value ? `url(#temperature_grad_sparkline_${v.value})` : t.value.style.line.color,
          fill: "none",
          "stroke-width": t.value.style.line.strokeWidth,
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          style: ae({
            transition: g(C) ? void 0 : "all 0.2s"
          })
        }, null, 12, el)) : S("", !0),
        !t.value.style.line.smooth && !U.value ? (p(), k("path", {
          key: 3,
          class: "vue-ui-sparkline-path",
          id: se.value,
          d: `M ${g(ft)(A.value) || "0,0"}`,
          stroke: ie.value ? `url(#temperature_grad_sparkline_${v.value})` : t.value.style.line.color,
          fill: "none",
          "stroke-width": t.value.style.line.strokeWidth,
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          style: ae({
            transition: g(C) ? void 0 : "all 0.2s"
          })
        }, null, 12, tl)) : S("", !0),
        rt.value && !ie.value ? (p(), Te(Fa, {
          key: 4,
          svgPathData: rt.value,
          enabled: t.value.gradientPath.show && !U.value && !ie.value,
          strokeWidth: t.value.style.line.strokeWidth,
          highColor: t.value.gradientPath.colors.high,
          lowColor: t.value.gradientPath.colors.low,
          segments: t.value.gradientPath.segments
        }, null, 8, ["svgPathData", "enabled", "strokeWidth", "highColor", "lowColor", "segments"])) : S("", !0),
        xe.value && ee.value ? (p(), Te(pa, {
          key: 5,
          uid: v.value,
          svgRef: g(ce),
          pulsePathId: se.value,
          pulsePathLength: oe.value,
          pulseDur: de.value,
          pulseBegin: Se.value,
          pulseRepeatCount: ve.value,
          pulseFillMode: Pe.value,
          pulseKeyPoints: _e.value,
          pulseMotion: Y.value,
          pulse: T.value,
          pulseTrail: Ce.value,
          pulseTrailLength: ue.value,
          prefersReducedMotion: g(f),
          loading: g(C),
          isBar: U.value
        }, null, 8, ["uid", "svgRef", "pulsePathId", "pulsePathLength", "pulseDur", "pulseBegin", "pulseRepeatCount", "pulseFillMode", "pulseKeyPoints", "pulseMotion", "pulse", "pulseTrail", "pulseTrailLength", "prefersReducedMotion", "loading", "isBar"])) : S("", !0),
        (p(!0), k(be, null, $e(A.value, (s, h) => (p(), k("g", null, [
          U.value ? (p(), k("rect", {
            key: 0,
            x: s.x - s.width / 2,
            y: isNaN(s.absoluteValue > 0 ? s.y : he.value) ? 0 : s.absoluteValue > 0 ? s.y : he.value,
            width: s.width,
            height: isNaN(Math.abs(s.y - he.value)) ? 0 : Math.abs(s.y - he.value),
            fill: s.absoluteValue > 0 ? `url(#sparkline_bar_gradient_pos_${v.value})` : `url(#sparkline_bar_gradient_neg_${v.value})`,
            rx: t.value.style.bar.borderRadius
          }, null, 8, al)) : S("", !0),
          t.value.style.verticalIndicator.show && (L.value && s.id === L.value.id || e.selectedIndex === h) ? (p(), k("line", {
            key: 1,
            x1: s.x,
            x2: s.x,
            y1: x.value.top - 6,
            y2: x.value.bottom,
            stroke: t.value.style.verticalIndicator.color || s.color,
            "stroke-width": t.value.style.verticalIndicator.strokeWidth,
            "stroke-linecap": "round",
            "stroke-dasharray": t.value.style.verticalIndicator.strokeDasharray || 0
          }, null, 8, ll)) : S("", !0)
        ]))), 256)),
        ze.value < 0 ? (p(), k("line", {
          key: 6,
          x1: x.value.start,
          x2: x.value.start + x.value.width,
          y1: g(pt)(he.value, x.value.bottom),
          y2: g(pt)(he.value, x.value.bottom),
          stroke: t.value.style.zeroLine.color,
          "stroke-dasharray": t.value.style.zeroLine.strokeWidth * 2,
          "stroke-width": t.value.style.zeroLine.strokeWidth,
          "stroke-linecap": "round"
        }, null, 8, nl)) : S("", !0),
        t.value.style.plot.show ? (p(!0), k(be, { key: 7 }, $e(A.value, (s, h) => (p(), k("g", null, [
          L.value && s.id === L.value.id || e.selectedIndex === h || g(J).length === 1 ? (p(), k("circle", {
            key: 0,
            cx: s.x,
            cy: s.y,
            r: t.value.style.plot.radius,
            fill: s.color,
            stroke: t.value.style.plot.stroke,
            "stroke-width": t.value.style.plot.strokeWidth
          }, null, 8, rl)) : S("", !0)
        ]))), 256)) : S("", !0),
        e.showInfo && t.value.style.dataLabel.show ? (p(), k("text", {
          key: 8,
          x: t.value.style.dataLabel.position === "left" ? 12 + t.value.style.dataLabel.offsetX : x.value.width + 12 + t.value.style.dataLabel.offsetX,
          y: b.value.height / 2 + t.value.style.dataLabel.fontSize / 2.5 + t.value.style.dataLabel.offsetY,
          "font-size": t.value.style.dataLabel.fontSize,
          "font-weight": t.value.style.dataLabel.bold ? "bold" : "normal",
          fill: t.value.style.dataLabel.color
        }, Ie(L.value ? g(We)(
          t.value.style.dataLabel.formatter,
          L.value.absoluteValue,
          g(je)({ p: t.value.style.dataLabel.prefix, v: L.value.absoluteValue, s: t.value.style.dataLabel.suffix, r: t.value.style.dataLabel.roundingValue }),
          { datapoint: L.value }
        ) : g(We)(
          t.value.style.dataLabel.formatter,
          nt.value,
          g(je)({ p: t.value.style.dataLabel.prefix, v: nt.value, s: t.value.style.dataLabel.suffix, r: t.value.style.dataLabel.roundingValue })
        )), 9, ol)) : S("", !0),
        (p(!0), k(be, null, $e(A.value, (s, h) => (p(), k("rect", {
          x: s.x - (x.value.width / (fe.value + 1) > b.value.padding ? b.value.padding : x.value.width / (fe.value + 1)) / 2,
          y: x.value.top - 6,
          height: x.value.height + 6,
          width: x.value.width / (fe.value + 1) > b.value.padding ? b.value.padding : x.value.width / (fe.value + 1),
          fill: "transparent",
          onMouseenter: () => Tt(s, h),
          onMouseleave: () => It(s, h),
          onClick: () => Et(s, h)
        }, null, 40, ul))), 256)),
        ge(n.$slots, "svg", { svg: b.value }, void 0, !0)
      ], 44, Ba)),
      L.value && t.value.style.tooltip.show ? (p(), Te(g(u), {
        key: 1,
        x: L.value.x,
        y: L.value.y,
        prevX: pe.value.x,
        prevY: pe.value.y,
        offsetY: t.value.style.plot.radius * 3 + t.value.style.tooltip.offsetY,
        svgRef: g(ce),
        background: t.value.style.tooltip.backgroundColor,
        color: t.value.style.tooltip.color,
        fontSize: t.value.style.tooltip.fontSize,
        borderWidth: t.value.style.tooltip.borderWidth,
        borderColor: t.value.style.tooltip.borderColor,
        borderRadius: t.value.style.tooltip.borderRadius,
        backgroundOpacity: t.value.style.tooltip.backgroundOpacity
      }, {
        default: Ot(() => [
          ge(n.$slots, "tooltip", it(ct({ ...L.value })), () => [
            qt(Ie(L.value.period) + ": " + Ie(g(We)(
              t.value.style.dataLabel.formatter,
              L.value.absoluteValue,
              g(je)({
                p: t.value.style.dataLabel.prefix,
                v: L.value.absoluteValue,
                s: t.value.style.dataLabel.suffix,
                r: t.value.style.dataLabel.roundingValue
              }),
              { datapoint: L.value }
            )), 1)
          ], !0)
        ]),
        _: 3
      }, 8, ["x", "y", "prevX", "prevY", "offsetY", "svgRef", "background", "color", "fontSize", "borderWidth", "borderColor", "borderRadius", "backgroundOpacity"])) : S("", !0),
      n.$slots.source ? (p(), k("div", {
        key: 2,
        ref_key: "source",
        ref: N,
        dir: "auto"
      }, [
        ge(n.$slots, "source", {}, void 0, !0)
      ], 512)) : S("", !0),
      ge(n.$slots, "skeleton", {}, () => [
        g(C) ? (p(), Te(ea, { key: 0 })) : S("", !0)
      ], !0)
    ], 12, Ra));
  }
}, il = /* @__PURE__ */ na(sl, [["__scopeId", "data-v-94a7557f"]]), kl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: il
}, Symbol.toStringTag, { value: "Module" }));
export {
  bl as a,
  kl as b,
  il as v
};
