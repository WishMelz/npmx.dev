// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
import { instantiate } from "./deno_doc_wasm.generated.js";
import { createCache } from "@jsr/deno__cache-dir";
// Removed: export * from "./types.d.ts"; (incompatible with Node.js/Rollup)
// Removed: export * from "./html_types.d.ts"; (incompatible with Node.js/Rollup)
const encoder = new TextEncoder();
/**
 * Generate asynchronously an array of documentation nodes for the supplied
 * module.
 *
 * ### Example
 *
 * ```ts
 * import { doc } from "https://deno.land/x/deno_doc/mod.ts";
 *
 * const entries = await doc(["https://deno.land/std/fmt/colors.ts"]);
 *
 * for (const entry of entries) {
 *   console.log(`name: ${entry.name} kind: ${entry.kind}`);
 * }
 * ```
 *
 * @param specifiers List of the URL strings of the specifiers to document
 * @param options A set of options for generating the documentation
 * @returns A promise that resolves with an array of documentation nodes
 */ export async function doc(specifiers, options = {}) {
  const { load = createCache().load, includeAll = false, resolve, importMap, printImportMapDiagnostics = true } = options;
  const wasm = await instantiate();
  return wasm.doc(specifiers, includeAll, (specifier, options)=>{
    return load(specifier, options.isDynamic, options.cacheSetting, options.checksum).then((result)=>{
      if (result?.kind === "module") {
        if (typeof result.content === "string") {
          result.content = encoder.encode(result.content);
        }
        // need to convert to an array for serde_wasm_bindgen to work
        // deno-lint-ignore no-explicit-any
        result.content = Array.from(result.content);
      }
      return result;
    });
  }, resolve, importMap, printImportMapDiagnostics);
}
const defaultUsageComposer = {
  singleMode: true,
  compose (currentResolve, usageToMd) {
    if ("file" in currentResolve) {
      return new Map([
        [
          {
            name: ""
          },
          usageToMd(currentResolve.file.specifier, undefined)
        ]
      ]);
    } else {
      return new Map();
    }
  }
};
/**
 * Generate HTML files for provided {@linkcode DocNode}s.
 * @param docNodesByUrl DocNodes keyed by their absolute URL.
 * @param options Options for the generation.
 */ export async function generateHtml(docNodesByUrl, options) {
  const { usageComposer = defaultUsageComposer } = options;
  const wasm = await instantiate();
  return wasm.generate_html(options.packageName, options.mainEntrypoint, usageComposer.singleMode, usageComposer.compose, options.rewriteMap, options.categoryDocs, options.disableSearch ?? false, options.symbolRedirectMap, options.defaultSymbolMap, options.hrefResolver?.resolvePath, options.hrefResolver?.resolveGlobalSymbol || (()=>undefined), options.hrefResolver?.resolveImportHref || (()=>undefined), options.hrefResolver?.resolveSource || (()=>undefined), options.hrefResolver?.resolveExternalJsdocModule || (()=>undefined), options.markdownRenderer, options.markdownStripper, options.headInject, options.idPrefix, docNodesByUrl, false);
}
/**
 * Generate JSON data equivalent to the HTML files generated by {@linkcode generateHtml}.
 * @param docNodesByUrl DocNodes keyed by their absolute URL.
 * @param options Options for the generation.
 */ export async function generateHtmlAsJSON(docNodesByUrl, options) {
  const { usageComposer = defaultUsageComposer } = options;
  const wasm = await instantiate();
  return wasm.generate_html(options.packageName, options.mainEntrypoint, usageComposer.singleMode, usageComposer.compose, options.rewriteMap, options.categoryDocs, options.disableSearch ?? false, options.symbolRedirectMap, options.defaultSymbolMap, options.hrefResolver?.resolvePath, options.hrefResolver?.resolveGlobalSymbol || (()=>undefined), options.hrefResolver?.resolveImportHref || (()=>undefined), options.hrefResolver?.resolveSource || (()=>undefined), options.hrefResolver?.resolveExternalJsdocModule || (()=>undefined), options.markdownRenderer, options.markdownStripper, options.headInject, options.idPrefix, docNodesByUrl, true);
}
//# sourceMappingURL=mod.js.map